; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\short_wave\obj\bsp_adc.o --asm_dir=.\short_wave\List\ --list_dir=.\short_wave\List\ --depend=.\short_wave\obj\bsp_adc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\adc -I..\..\User\rtc -I..\..\User\internal_flash -I..\..\User\iwdg -I..\..\Task -I..\..\User\can -I..\..\User\firmware_upgrade -I..\..\User\STMFLASH -I..\..\User\IAP -I.\RTE\_Short_Wave -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\short_wave\obj\bsp_adc.crf ..\..\User\adc\bsp_adc.c]
                          THUMB

                          AREA ||i.ADCx_GPIO_Config||, CODE, READONLY, ALIGN=2

                  ADCx_GPIO_Config PROC
;;;9        */
;;;10     static void ADCx_GPIO_Config(void)
000000  b508              PUSH     {r3,lr}
;;;11     {
;;;12         GPIO_InitTypeDef GPIO_InitStructure;
;;;13     
;;;14         // 打开 ADC IO端口时钟
;;;15         ADC_GPIO_APBxClock_FUN ( ADC_GPIO_CLK , ENABLE );
000002  2101              MOVS     r1,#1
000004  2010              MOVS     r0,#0x10
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;16         //只保留A口的8个ADC
;;;17         // 配置 ADC IO 引脚模式 GPIO C的ADC
;;;18         GPIO_InitStructure.GPIO_Pin =
00000a  200f              MOVS     r0,#0xf
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;19     			GPIO_Pin_0|
;;;20     			GPIO_Pin_1|
;;;21     			GPIO_Pin_2|
;;;22     			GPIO_Pin_3;
;;;23     
;;;24         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
000010  2000              MOVS     r0,#0
000012  f88d0003          STRB     r0,[sp,#3]
;;;25     
;;;26         // 初始化 ADC IO
;;;27         GPIO_Init(ADC_PORT, &GPIO_InitStructure);
000016  4669              MOV      r1,sp
000018  4801              LDR      r0,|L1.32|
00001a  f7fffffe          BL       GPIO_Init
;;;28     
;;;29         /*
;;;30         // 配置 ADC IO 引脚模式 GPIO A的ADC
;;;31         GPIO_InitStructure.GPIO_Pin =	GPIO_Pin_0|
;;;32     									GPIO_Pin_1|
;;;33     									GPIO_Pin_2|
;;;34     									GPIO_Pin_3|
;;;35     									GPIO_Pin_4|
;;;36     									GPIO_Pin_5|
;;;37     									GPIO_Pin_6|
;;;38     									GPIO_Pin_7;
;;;39     
;;;40         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
;;;41     
;;;42         // 初始化 ADC IO
;;;43         GPIO_Init(ADC_PORT_A_PORT, &GPIO_InitStructure);
;;;44         */
;;;45     }
00001e  bd08              POP      {r3,pc}
;;;46     
                          ENDP

                  |L1.32|
                          DCD      0x40011000

                          AREA ||i.ADCx_Init||, CODE, READONLY, ALIGN=1

                  ADCx_Init PROC
;;;172      */
;;;173    void ADCx_Init(void)
000000  b510              PUSH     {r4,lr}
;;;174    {
;;;175        ADCx_GPIO_Config();
000002  f7fffffe          BL       ADCx_GPIO_Config
;;;176        ADCx_Mode_Config();
000006  f7fffffe          BL       ADCx_Mode_Config
;;;177    }
00000a  bd10              POP      {r4,pc}
;;;178    /*********************************************END OF FILE**********************/
                          ENDP


                          AREA ||i.ADCx_Mode_Config||, CODE, READONLY, ALIGN=2

                  ADCx_Mode_Config PROC
;;;51       */
;;;52     static void ADCx_Mode_Config(void)
000000  b500              PUSH     {lr}
;;;53     {
000002  b091              SUB      sp,sp,#0x44
;;;54         DMA_InitTypeDef DMA_InitStructure;
;;;55         ADC_InitTypeDef ADC_InitStructure;
;;;56     
;;;57         // 打开DMA时钟
;;;58         RCC_AHBPeriphClockCmd(ADC_DMA_CLK, ENABLE);
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;59         // 打开ADC时钟
;;;60         ADC_APBxClock_FUN ( ADC_CLK, ENABLE );
00000c  2101              MOVS     r1,#1
00000e  0248              LSLS     r0,r1,#9
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;61     
;;;62         // 复位DMA控制器
;;;63         DMA_DeInit(ADC_DMA_CHANNEL);
000014  483d              LDR      r0,|L3.268|
000016  f7fffffe          BL       DMA_DeInit
;;;64     
;;;65         // 配置 DMA 初始化结构体
;;;66         // 外设基址为：ADC 数据寄存器地址
;;;67         DMA_InitStructure.DMA_PeripheralBaseAddr = ( u32 ) ( & ( ADC_x->DR ) );
00001a  483d              LDR      r0,|L3.272|
00001c  9006              STR      r0,[sp,#0x18]
;;;68     
;;;69         // 存储器地址
;;;70         DMA_InitStructure.DMA_MemoryBaseAddr = (u32)ADC_ConvertedValue;
00001e  483d              LDR      r0,|L3.276|
000020  9007              STR      r0,[sp,#0x1c]
;;;71     
;;;72         // 数据源来自外设
;;;73         DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
000022  2000              MOVS     r0,#0
000024  9008              STR      r0,[sp,#0x20]
;;;74     
;;;75         // 缓冲区大小，应该等于数据目的地的大小
;;;76         DMA_InitStructure.DMA_BufferSize = NOFCHANEL;
000026  2004              MOVS     r0,#4
000028  9009              STR      r0,[sp,#0x24]
;;;77     
;;;78         // 外设寄存器只有一个，地址不用递增
;;;79         DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
00002a  2000              MOVS     r0,#0
00002c  900a              STR      r0,[sp,#0x28]
;;;80     
;;;81         // 存储器地址递增
;;;82         DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
00002e  2080              MOVS     r0,#0x80
000030  900b              STR      r0,[sp,#0x2c]
;;;83     
;;;84         // 外设数据大小为半字，即两个字节
;;;85         DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
000032  0040              LSLS     r0,r0,#1
000034  900c              STR      r0,[sp,#0x30]
;;;86     
;;;87         // 内存数据大小也为半字，跟外设数据大小相同
;;;88         DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
000036  0080              LSLS     r0,r0,#2
000038  900d              STR      r0,[sp,#0x34]
;;;89     
;;;90         // 循环传输模式
;;;91         DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
00003a  2020              MOVS     r0,#0x20
00003c  900e              STR      r0,[sp,#0x38]
;;;92     
;;;93         // DMA 传输通道优先级为高，当使用一个DMA通道时，优先级设置不影响
;;;94         DMA_InitStructure.DMA_Priority = DMA_Priority_High;
00003e  0200              LSLS     r0,r0,#8
000040  900f              STR      r0,[sp,#0x3c]
;;;95     
;;;96         // 禁止存储器到存储器模式，因为是从外设到存储器
;;;97         DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
000042  2000              MOVS     r0,#0
000044  9010              STR      r0,[sp,#0x40]
;;;98     
;;;99         // 初始化DMA
;;;100        DMA_Init(ADC_DMA_CHANNEL, &DMA_InitStructure);
000046  a906              ADD      r1,sp,#0x18
000048  4830              LDR      r0,|L3.268|
00004a  f7fffffe          BL       DMA_Init
;;;101    
;;;102        // 使能 DMA 通道
;;;103        DMA_Cmd(ADC_DMA_CHANNEL , ENABLE);
00004e  2101              MOVS     r1,#1
000050  482e              LDR      r0,|L3.268|
000052  f7fffffe          BL       DMA_Cmd
;;;104    
;;;105        // ADC 模式配置
;;;106        // 只使用一个ADC，属于单模式
;;;107        ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
000056  2000              MOVS     r0,#0
000058  9001              STR      r0,[sp,#4]
;;;108    
;;;109        // 扫描模式
;;;110        ADC_InitStructure.ADC_ScanConvMode = ENABLE ;
00005a  2001              MOVS     r0,#1
00005c  f88d0008          STRB     r0,[sp,#8]
;;;111    
;;;112        // 连续转换模式
;;;113        ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
000060  f88d0009          STRB     r0,[sp,#9]
;;;114    
;;;115        // 不用外部触发转换，软件开启即可
;;;116        ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
000064  f44f2060          MOV      r0,#0xe0000
000068  9003              STR      r0,[sp,#0xc]
;;;117    
;;;118        // 转换结果右对齐
;;;119        ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
00006a  2000              MOVS     r0,#0
00006c  9004              STR      r0,[sp,#0x10]
;;;120    
;;;121        // 转换通道个数
;;;122        ADC_InitStructure.ADC_NbrOfChannel = NOFCHANEL;
00006e  2004              MOVS     r0,#4
000070  f88d0014          STRB     r0,[sp,#0x14]
;;;123    
;;;124        // 初始化ADC
;;;125        ADC_Init(ADC_x, &ADC_InitStructure);
000074  a901              ADD      r1,sp,#4
000076  4826              LDR      r0,|L3.272|
000078  384c              SUBS     r0,r0,#0x4c
00007a  f7fffffe          BL       ADC_Init
;;;126    
;;;127        // 配置ADC时钟ＮPCLK2的8分频，即9MHz
;;;128        RCC_ADCCLKConfig(RCC_PCLK2_Div8);
00007e  f44f4040          MOV      r0,#0xc000
000082  f7fffffe          BL       RCC_ADCCLKConfig
;;;129    
;;;130        // 配置ADC 通道的转换顺序和采样时间
;;;131    //	ADC_RegularChannelConfig(ADC_x, ADC_CHANNEL0, 1, ADC_SampleTime_55Cycles5);
;;;132    //	ADC_RegularChannelConfig(ADC_x, ADC_CHANNEL1, 2, ADC_SampleTime_55Cycles5);
;;;133    //	ADC_RegularChannelConfig(ADC_x, ADC_CHANNEL2, 3, ADC_SampleTime_55Cycles5);
;;;134    //	ADC_RegularChannelConfig(ADC_x, ADC_CHANNEL3, 4, ADC_SampleTime_55Cycles5);
;;;135    //	ADC_RegularChannelConfig(ADC_x, ADC_CHANNEL4, 5, ADC_SampleTime_55Cycles5);
;;;136    //	ADC_RegularChannelConfig(ADC_x, ADC_CHANNEL5, 6, ADC_SampleTime_55Cycles5);
;;;137    //	ADC_RegularChannelConfig(ADC_x, ADC_CHANNEL6, 7, ADC_SampleTime_55Cycles5);
;;;138    //	ADC_RegularChannelConfig(ADC_x, ADC_CHANNEL7, 8, ADC_SampleTime_55Cycles5);
;;;139    //	ADC_RegularChannelConfig(ADC_x, ADC_CHANNEL9, 9, ADC_SampleTime_55Cycles5);
;;;140    //	ADC_RegularChannelConfig(ADC_x, ADC_CHANNEL9, 1, ADC_SampleTime_55Cycles5);
;;;141        ADC_RegularChannelConfig(ADC_x, ADC_CHANNEL10, 1, ADC_SampleTime_55Cycles5);
000086  2305              MOVS     r3,#5
000088  2201              MOVS     r2,#1
00008a  210a              MOVS     r1,#0xa
00008c  4820              LDR      r0,|L3.272|
00008e  384c              SUBS     r0,r0,#0x4c
000090  f7fffffe          BL       ADC_RegularChannelConfig
;;;142        ADC_RegularChannelConfig(ADC_x, ADC_CHANNEL11, 2, ADC_SampleTime_55Cycles5);
000094  2305              MOVS     r3,#5
000096  2202              MOVS     r2,#2
000098  210b              MOVS     r1,#0xb
00009a  481d              LDR      r0,|L3.272|
00009c  384c              SUBS     r0,r0,#0x4c
00009e  f7fffffe          BL       ADC_RegularChannelConfig
;;;143        ADC_RegularChannelConfig(ADC_x, ADC_CHANNEL12, 3, ADC_SampleTime_55Cycles5);
0000a2  2305              MOVS     r3,#5
0000a4  2203              MOVS     r2,#3
0000a6  210c              MOVS     r1,#0xc
0000a8  4819              LDR      r0,|L3.272|
0000aa  384c              SUBS     r0,r0,#0x4c
0000ac  f7fffffe          BL       ADC_RegularChannelConfig
;;;144        ADC_RegularChannelConfig(ADC_x, ADC_CHANNEL13, 4, ADC_SampleTime_55Cycles5);
0000b0  2305              MOVS     r3,#5
0000b2  2204              MOVS     r2,#4
0000b4  210d              MOVS     r1,#0xd
0000b6  4816              LDR      r0,|L3.272|
0000b8  384c              SUBS     r0,r0,#0x4c
0000ba  f7fffffe          BL       ADC_RegularChannelConfig
;;;145    //	ADC_RegularChannelConfig(ADC_x, ADC_CHANNEL14, 15, ADC_SampleTime_55Cycles5);
;;;146    //	ADC_RegularChannelConfig(ADC_x, ADC_CHANNEL15, 16, ADC_SampleTime_55Cycles5);
;;;147    
;;;148        // 使能ADC DMA 请求
;;;149        ADC_DMACmd(ADC_x, ENABLE);
0000be  2101              MOVS     r1,#1
0000c0  4813              LDR      r0,|L3.272|
0000c2  384c              SUBS     r0,r0,#0x4c
0000c4  f7fffffe          BL       ADC_DMACmd
;;;150    
;;;151        // 开启ADC ，并开始转换
;;;152        ADC_Cmd(ADC_x, ENABLE);
0000c8  2101              MOVS     r1,#1
0000ca  4811              LDR      r0,|L3.272|
0000cc  384c              SUBS     r0,r0,#0x4c
0000ce  f7fffffe          BL       ADC_Cmd
;;;153    
;;;154        // 初始化ADC 校准寄存器
;;;155        ADC_ResetCalibration(ADC_x);
0000d2  480f              LDR      r0,|L3.272|
0000d4  384c              SUBS     r0,r0,#0x4c
0000d6  f7fffffe          BL       ADC_ResetCalibration
;;;156        // 等待校准寄存器初始化完成
;;;157        while(ADC_GetResetCalibrationStatus(ADC_x));
0000da  bf00              NOP      
                  |L3.220|
0000dc  480c              LDR      r0,|L3.272|
0000de  384c              SUBS     r0,r0,#0x4c
0000e0  f7fffffe          BL       ADC_GetResetCalibrationStatus
0000e4  2800              CMP      r0,#0
0000e6  d1f9              BNE      |L3.220|
;;;158    
;;;159        // ADC开始校准
;;;160        ADC_StartCalibration(ADC_x);
0000e8  4809              LDR      r0,|L3.272|
0000ea  384c              SUBS     r0,r0,#0x4c
0000ec  f7fffffe          BL       ADC_StartCalibration
;;;161        // 等待校准完成
;;;162        while(ADC_GetCalibrationStatus(ADC_x));
0000f0  bf00              NOP      
                  |L3.242|
0000f2  4807              LDR      r0,|L3.272|
0000f4  384c              SUBS     r0,r0,#0x4c
0000f6  f7fffffe          BL       ADC_GetCalibrationStatus
0000fa  2800              CMP      r0,#0
0000fc  d1f9              BNE      |L3.242|
;;;163    
;;;164        // 由于没有采用外部触发，所以使用软件触发ADC转换
;;;165        ADC_SoftwareStartConvCmd(ADC_x, ENABLE);
0000fe  2101              MOVS     r1,#1
000100  4803              LDR      r0,|L3.272|
000102  384c              SUBS     r0,r0,#0x4c
000104  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;166    }
000108  b011              ADD      sp,sp,#0x44
00010a  bd00              POP      {pc}
;;;167    
                          ENDP

                  |L3.268|
                          DCD      0x40020008
                  |L3.272|
                          DCD      0x4001244c
                  |L3.276|
                          DCD      ADC_ConvertedValue

                          AREA ||.data||, DATA, ALIGN=1

                  ADC_ConvertedValue
000000  00000000          DCW      0x0000,0x0000
000004  00000000          DCW      0x0000,0x0000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\adc\\bsp_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_adc_c_937cc199____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_bsp_adc_c_937cc199____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_adc_c_937cc199____REVSH|
#line 128
|__asm___9_bsp_adc_c_937cc199____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
