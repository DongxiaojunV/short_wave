; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\short_wave\obj\bsp_rtc.o --asm_dir=.\short_wave\List\ --list_dir=.\short_wave\List\ --depend=.\short_wave\obj\bsp_rtc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\adc -I..\..\User\rtc -I..\..\User\internal_flash -I..\..\User\iwdg -I..\..\Task -I..\..\User\can -I..\..\User\firmware_upgrade -I..\..\User\STMFLASH -I..\..\User\IAP -I.\RTE\_Short_Wave -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\short_wave\obj\bsp_rtc.crf ..\..\User\rtc\bsp_rtc.c]
                          THUMB

                          AREA ||i.RTC_CheckAndConfig||, CODE, READONLY, ALIGN=1

                  RTC_CheckAndConfig PROC
;;;62      */
;;;63     void RTC_CheckAndConfig(struct rtc_time *tm)
000000  b510              PUSH     {r4,lr}
;;;64     {
000002  4604              MOV      r4,r0
;;;65         /*在启动时检查备份寄存器BKP_DR1，如果内容不是0xA5A5，则需重新配置时间并询问用户调整时间*/
;;;66         if (BKP_ReadBackupRegister(RTC_BKP_DRX) != RTC_BKP_DATA)
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       BKP_ReadBackupRegister
00000a  f24a51a5          MOV      r1,#0xa5a5
00000e  4288              CMP      r0,r1
000010  d008              BEQ      |L1.36|
;;;67         {
;;;68     		#if	PRINTF_EN
;;;69     		printf("\r\nRTC not yet configured....");
;;;70             printf("\r\nRTC configured....\r\n");
;;;71     		#endif
;;;72     		
;;;73             /* 使用tm的时间配置RTC寄存器 */
;;;74             Time_Adjust(tm);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       Time_Adjust
;;;75     
;;;76             /*向BKP_DR1寄存器写入标志，说明RTC已在运行*/
;;;77             BKP_WriteBackupRegister(RTC_BKP_DRX, RTC_BKP_DATA);
000018  f24a51a5          MOV      r1,#0xa5a5
00001c  2004              MOVS     r0,#4
00001e  f7fffffe          BL       BKP_WriteBackupRegister
000022  e016              B        |L1.82|
                  |L1.36|
;;;78         }
;;;79         else
;;;80         {
;;;81             /* 使能 PWR 和 Backup 时钟 */
;;;82             RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
000024  2101              MOVS     r1,#1
000026  f04f50c0          MOV      r0,#0x18000000
00002a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;83     
;;;84             /* 允许访问 Backup 区域 */
;;;85             PWR_BackupAccessCmd(ENABLE);
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       PWR_BackupAccessCmd
;;;86     		
;;;87             /*LSE启动无需设置新时钟*/
;;;88     #ifdef RTC_CLOCK_SOURCE_LSI
;;;89             /* 使能 LSI */
;;;90             RCC_LSICmd(ENABLE);
;;;91     
;;;92             /* 等待 LSI 准备好 */
;;;93             while (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
;;;94             {}
;;;95     #endif
;;;96     
;;;97             /*检查是否掉电重启*/
;;;98             if (RCC_GetFlagStatus(RCC_FLAG_PORRST) != RESET)
000034  207b              MOVS     r0,#0x7b
000036  f7fffffe          BL       RCC_GetFlagStatus
00003a  b910              CBNZ     r0,|L1.66|
;;;99             {
;;;100    			#if	PRINTF_EN
;;;101                printf("\r\nPower On Reset occurred....");
;;;102    			#endif
;;;103            }
;;;104            /*检查是否Reset复位*/
;;;105            else if (RCC_GetFlagStatus(RCC_FLAG_PINRST) != RESET)
00003c  207a              MOVS     r0,#0x7a
00003e  f7fffffe          BL       RCC_GetFlagStatus
                  |L1.66|
;;;106            {
;;;107    			#if	PRINTF_EN
;;;108                printf("\r\nExternal Reset occurred....");
;;;109    			#endif
;;;110            }
;;;111    		
;;;112    		#if	PRINTF_EN
;;;113            printf("\r\nNo need to configure RTC....");
;;;114    		#endif
;;;115    		
;;;116    		/*等待寄存器同步*/
;;;117            RTC_WaitForSynchro();
000042  f7fffffe          BL       RTC_WaitForSynchro
;;;118    
;;;119            /*允许RTC秒中断*/
;;;120            RTC_ITConfig(RTC_IT_SEC, ENABLE);
000046  2101              MOVS     r1,#1
000048  4608              MOV      r0,r1
00004a  f7fffffe          BL       RTC_ITConfig
;;;121    
;;;122            /*等待上次RTC寄存器写操作完成*/
;;;123            RTC_WaitForLastTask();
00004e  f7fffffe          BL       RTC_WaitForLastTask
                  |L1.82|
;;;124        }
;;;125    
;;;126    	RTC_NVIC_Config();
000052  f7fffffe          BL       RTC_NVIC_Config
;;;127    	
;;;128        /* 清除复位标志 flags */
;;;129        RCC_ClearFlag();
000056  f7fffffe          BL       RCC_ClearFlag
;;;130    }
00005a  bd10              POP      {r4,pc}
;;;131    
                          ENDP


                          AREA ||i.RTC_Configuration||, CODE, READONLY, ALIGN=1

                  RTC_Configuration PROC
;;;140     */
;;;141    void RTC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;142    {
;;;143        /* 使能 PWR 和 Backup 时钟 */
;;;144        RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
000002  2101              MOVS     r1,#1
000004  f04f50c0          MOV      r0,#0x18000000
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;145    
;;;146        /* 允许访问 Backup 区域 */
;;;147        PWR_BackupAccessCmd(ENABLE);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       PWR_BackupAccessCmd
;;;148    
;;;149        /* 复位 Backup 区域 */
;;;150        BKP_DeInit();
000012  f7fffffe          BL       BKP_DeInit
;;;151    
;;;152    //使用外部时钟还是内部时钟（在bsp_rtc.h文件定义）
;;;153    //使用外部时钟时，在有些情况下晶振不起振
;;;154    //批量产品的时候，很容易出现外部晶振不起振的情况，不太可靠
;;;155    #ifdef 	RTC_CLOCK_SOURCE_LSE
;;;156        /* 使能 LSE */
;;;157        RCC_LSEConfig(RCC_LSE_ON);
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       RCC_LSEConfig
;;;158    
;;;159        /* 等待 LSE 准备好 */
;;;160        while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
00001c  bf00              NOP      
                  |L2.30|
00001e  2041              MOVS     r0,#0x41
000020  f7fffffe          BL       RCC_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0fa              BEQ      |L2.30|
;;;161        {}
;;;162    
;;;163        /* 选择 LSE 作为 RTC 时钟源 */
;;;164        RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
000028  f44f7080          MOV      r0,#0x100
00002c  f7fffffe          BL       RCC_RTCCLKConfig
;;;165    
;;;166        /* 使能 RTC 时钟 */
;;;167        RCC_RTCCLKCmd(ENABLE);
000030  2001              MOVS     r0,#1
000032  f7fffffe          BL       RCC_RTCCLKCmd
;;;168    		
;;;169        /* 等待 RTC 寄存器 同步
;;;170         * 因为RTC时钟是低速的，内环时钟是高速的，所以要同步
;;;171         */
;;;172        RTC_WaitForSynchro();
000036  f7fffffe          BL       RTC_WaitForSynchro
;;;173    
;;;174    	/* 确保上一次 RTC 的操作完成 */
;;;175        RTC_WaitForLastTask();
00003a  f7fffffe          BL       RTC_WaitForLastTask
;;;176    	
;;;177        /* 使能 RTC 秒中断 */
;;;178        RTC_ITConfig(RTC_IT_SEC, ENABLE);
00003e  2101              MOVS     r1,#1
000040  4608              MOV      r0,r1
000042  f7fffffe          BL       RTC_ITConfig
;;;179    
;;;180        /* 确保上一次 RTC 的操作完成 */
;;;181        RTC_WaitForLastTask();
000046  f7fffffe          BL       RTC_WaitForLastTask
;;;182    
;;;183        /* 设置 RTC 分频: 使 RTC 周期为1s  */
;;;184        /* RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1) = 1HZ */
;;;185        RTC_SetPrescaler(32767);
00004a  f64770ff          MOV      r0,#0x7fff
00004e  f7fffffe          BL       RTC_SetPrescaler
;;;186    
;;;187        /* 确保上一次 RTC 的操作完成 */
;;;188        RTC_WaitForLastTask();
000052  f7fffffe          BL       RTC_WaitForLastTask
;;;189    
;;;190    #else
;;;191    
;;;192        /* 使能 LSI */
;;;193        RCC_LSICmd(ENABLE);
;;;194    
;;;195        /* 等待 LSI 准备好 */
;;;196        while (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
;;;197        {}
;;;198    
;;;199        /* 选择 LSI 作为 RTC 时钟源 */
;;;200        RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);
;;;201    
;;;202        /* 使能 RTC 时钟 */
;;;203        RCC_RTCCLKCmd(ENABLE);
;;;204    
;;;205        /* 等待 RTC 寄存器 同步
;;;206         * 因为RTC时钟是低速的，内环时钟是高速的，所以要同步
;;;207         */
;;;208        RTC_WaitForSynchro();
;;;209    
;;;210        /* 确保上一次 RTC 的操作完成 */
;;;211        RTC_WaitForLastTask();
;;;212    
;;;213        /* 使能 RTC 秒中断 */
;;;214        RTC_ITConfig(RTC_IT_SEC, ENABLE);
;;;215    
;;;216        /* 确保上一次 RTC 的操作完成 */
;;;217        RTC_WaitForLastTask();
;;;218    
;;;219        /* 设置 RTC 分频: 使 RTC 周期为1s ,LSI约为40KHz */
;;;220        /* RTC period = RTCCLK/RTC_PR = (40 KHz)/(40000-1+1) = 1HZ */
;;;221        RTC_SetPrescaler(40000-1);
;;;222    
;;;223        /* 确保上一次 RTC 的操作完成 */
;;;224        RTC_WaitForLastTask();
;;;225    #endif
;;;226    
;;;227        ErrorStatus HSEStartUpStatus;
;;;228        HSEStartUpStatus = RCC_WaitForHSEStartUp(); //获取HSE启动状态
000056  f7fffffe          BL       RCC_WaitForHSEStartUp
00005a  4604              MOV      r4,r0
;;;229        if(HSEStartUpStatus == SUCCESS)            //如果HSE启动成功
;;;230        {
;;;231    		#if	PRINTF_EN
;;;232            printf("extern RTC running!\r\n");
;;;233    		#endif
;;;234        }
;;;235        else
;;;236        {
;;;237    		#if	PRINTF_EN
;;;238            printf("start extern RTC failure!\r\n");
;;;239    		#endif
;;;240        }
;;;241    }
00005c  bd10              POP      {r4,pc}
;;;242    
                          ENDP


                          AREA ||i.RTC_NVIC_Config||, CODE, READONLY, ALIGN=1

                  RTC_NVIC_Config PROC
;;;39      */
;;;40     void RTC_NVIC_Config(void)
000000  b508              PUSH     {r3,lr}
;;;41     {
;;;42         NVIC_InitTypeDef NVIC_InitStructure;
;;;43     
;;;44         /* Configure one bit for preemption priority */
;;;45     //	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
;;;46     
;;;47         /* Enable the RTC Interrupt */
;;;48         NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQn;
000002  2003              MOVS     r0,#3
000004  f88d0000          STRB     r0,[sp,#0]
;;;49         NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 9;
000008  2009              MOVS     r0,#9
00000a  f88d0001          STRB     r0,[sp,#1]
;;;50         NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00000e  2000              MOVS     r0,#0
000010  f88d0002          STRB     r0,[sp,#2]
;;;51         NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000014  2001              MOVS     r0,#1
000016  f88d0003          STRB     r0,[sp,#3]
;;;52         NVIC_Init(&NVIC_InitStructure);
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       NVIC_Init
;;;53     }
000020  bd08              POP      {r3,pc}
;;;54     
                          ENDP


                          AREA ||i.Time_Adjust||, CODE, READONLY, ALIGN=1

                  Time_Adjust PROC
;;;441    //时间日期写入到RTC计数寄存器
;;;442    void Time_Adjust(struct rtc_time *tm)
000000  b570              PUSH     {r4-r6,lr}
;;;443    {
000002  4604              MOV      r4,r0
;;;444        /* RTC 配置 */
;;;445        RTC_Configuration();
000004  f7fffffe          BL       RTC_Configuration
;;;446    
;;;447        /* 等待确保上一次操作完成 */
;;;448        RTC_WaitForLastTask();
000008  f7fffffe          BL       RTC_WaitForLastTask
;;;449    
;;;450        /* 计算星期 */
;;;451        //  GregorianDay(tm);
;;;452    
;;;453        /* 由日期计算时间戳并写入到RTC计数寄存器 */
;;;454        RTC_SetCounter(mktimev(tm)-TIME_ZOOM);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       mktimev
000012  4605              MOV      r5,r0
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       RTC_SetCounter
;;;455    
;;;456        /* 等待确保上一次操作完成 */
;;;457        RTC_WaitForLastTask();
00001a  f7fffffe          BL       RTC_WaitForLastTask
;;;458    }
00001e  bd70              POP      {r4-r6,pc}
;;;459    
                          ENDP


                          AREA ||i.Time_Printf||, CODE, READONLY, ALIGN=2

                  Time_Printf PROC
;;;467    //时间戳 -> 北京时间并打印
;;;468    void Time_Printf(uint32_t TimeVar,struct rtc_time *tm)
000000  b57f              PUSH     {r0-r6,lr}
;;;469    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;470        uint32_t BJ_TimeVar;
;;;471    
;;;472        /*  把标准时间转换为北京时间*/
;;;473        BJ_TimeVar = TimeVar + TIME_ZOOM;
000006  462e              MOV      r6,r5
;;;474    
;;;475        to_tm(BJ_TimeVar, tm);/*把定时器的值转换为北京时间*/
000008  4621              MOV      r1,r4
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       to_tm
;;;476    
;;;477        /* 输出时间戳，公历时间 */
;;;478        App_printf("UNIX Stamp = %d	%d-%d-%d	%0.2d:%0.2d:%0.2d\r\n",
000010  e894000b          LDM      r4,{r0,r1,r3}
000014  68e2              LDR      r2,[r4,#0xc]
000016  e9cd2300          STRD     r2,r3,[sp,#0]
00001a  e9cd1002          STRD     r1,r0,[sp,#8]
00001e  4629              MOV      r1,r5
000020  a002              ADR      r0,|L5.44|
000022  e9d43204          LDRD     r3,r2,[r4,#0x10]
000026  f7fffffe          BL       App_printf
;;;479                   TimeVar,
;;;480                   tm->tm_year, tm->tm_mon, tm->tm_mday,
;;;481                   tm->tm_hour, tm->tm_min, tm->tm_sec);
;;;482    }
00002a  bd7f              POP      {r0-r6,pc}
;;;483    
                          ENDP

                  |L5.44|
00002c  554e4958          DCB      "UNIX Stamp = %d\t%d-%d-%d\t%0.2d:%0.2d:%0.2d\r\n",0
000030  20537461
000034  6d70203d
000038  20256409
00003c  25642d25
000040  642d2564
000044  0925302e
000048  32643a25
00004c  302e3264
000050  3a25302e
000054  32640d0a
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.update_RTCtime||, CODE, READONLY, ALIGN=1

                  update_RTCtime PROC
;;;484    //时间戳 -> 北京时间
;;;485    void update_RTCtime(uint32_t TimeVar,struct rtc_time *tm)
000000  b570              PUSH     {r4-r6,lr}
;;;486    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;487        uint32_t BJ_TimeVar;
;;;488    
;;;489        /*  把标准时间转换为北京时间*/
;;;490        BJ_TimeVar = TimeVar + TIME_ZOOM;
000006  4626              MOV      r6,r4
;;;491    
;;;492        to_tm(BJ_TimeVar, tm);/*把定时器的值转换为北京时间*/
000008  4629              MOV      r1,r5
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       to_tm
;;;493    
;;;494        //更新时间，不打印
;;;495    //    App_printf("update_RTCtime...\r\n");
;;;496    //    App_printf("UNIX Stamp = %d	%d-%d-%d	%0.2d:%0.2d:%0.2d\r\n",
;;;497    //				TimeVar,
;;;498    //				tm->tm_year, tm->tm_mon, tm->tm_mday,
;;;499    //				tm->tm_hour, tm->tm_min, tm->tm_sec);
;;;500    
;;;501    //    App_printf("UNIX时间戳 = %d 当前时间为: %d年(%s年) %d月 %d日   %0.2d:%0.2d:%0.2d\r\n",TimeVar,
;;;502    //               tm->tm_year, zodiac_sign[(tm->tm_year-3)%12], tm->tm_mon, tm->tm_mday,
;;;503    //               tm->tm_hour, tm->tm_min, tm->tm_sec);
;;;504    }
000010  bd70              POP      {r4-r6,pc}
;;;505    
                          ENDP


                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  c8d500            DCB      200,213,0
000003  00                DCB      0
000004  d2bb00            DCB      210,187,0
000007  00                DCB      0
000008  b6fe00            DCB      182,254,0
00000b  00                DCB      0
00000c  c8fd00            DCB      200,253,0
00000f  00                DCB      0
000010  cbc400            DCB      203,196,0
000013  00                DCB      0
000014  cee500            DCB      206,229,0
000017  00                DCB      0
000018  c1f900            DCB      193,249,0
00001b  00                DCB      0
00001c  d6ed00            DCB      214,237,0
00001f  00                DCB      0
000020  caf300            DCB      202,243,0
000023  00                DCB      0
000024  c5a300            DCB      197,163,0
000027  00                DCB      0
000028  bba200            DCB      187,162,0
00002b  00                DCB      0
00002c  cdc300            DCB      205,195,0
00002f  00                DCB      0
000030  c1fa00            DCB      193,250,0
000033  00                DCB      0
000034  c9df00            DCB      201,223,0
000037  00                DCB      0
000038  c2ed00            DCB      194,237,0
00003b  00                DCB      0
00003c  d1f200            DCB      209,242,0
00003f  00                DCB      0
000040  baef00            DCB      186,239,0
000043  00                DCB      0
000044  bca600            DCB      188,166,0
000047  00                DCB      0
000048  b9b700            DCB      185,183,0
00004b  00                DCB      0
00004c  53756e64          DCB      "Sunday",0
000050  617900  
000053  00                DCB      0
000054  4d6f6e64          DCB      "Monday",0
000058  617900  
00005b  00                DCB      0
00005c  54756573          DCB      "Tuesday",0
000060  64617900
000064  5765646e          DCB      "Wednesday",0
000068  65736461
00006c  7900    
00006e  00                DCB      0
00006f  00                DCB      0
000070  54687572          DCB      "Thursday",0
000074  73646179
000078  00      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0
00007c  46726964          DCB      "Friday",0
000080  617900  
000083  00                DCB      0
000084  53617475          DCB      "Saturday",0
000088  72646179
00008c  00      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0
000090  50696700          DCB      "Pig",0
000094  52617400          DCB      "Rat",0
000098  4f7800            DCB      "Ox",0
00009b  00                DCB      0
00009c  54696765          DCB      "Tiger",0
0000a0  7200    
0000a2  00                DCB      0
0000a3  00                DCB      0
0000a4  52616262          DCB      "Rabbit",0
0000a8  697400  
0000ab  00                DCB      0
0000ac  44726167          DCB      "Dragon",0
0000b0  6f6e00  
0000b3  00                DCB      0
0000b4  536e616b          DCB      "Snake",0
0000b8  6500    
0000ba  00                DCB      0
0000bb  00                DCB      0
0000bc  486f7273          DCB      "Horse",0
0000c0  6500    
0000c2  00                DCB      0
0000c3  00                DCB      0
0000c4  476f6174          DCB      "Goat",0
0000c8  00      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0
0000cc  4d6f6e6b          DCB      "Monkey",0
0000d0  657900  
0000d3  00                DCB      0
0000d4  526f6f73          DCB      "Rooster",0
0000d8  74657200
0000dc  446f6700          DCB      "Dog",0

                          AREA ||.data||, DATA, ALIGN=2

                  TimeDisplay
                          DCD      0x00000000
                  WEEK_STR
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0x4
                          DCD      ||.conststring||+0x8
                          DCD      ||.conststring||+0xc
                          DCD      ||.conststring||+0x10
                          DCD      ||.conststring||+0x14
                          DCD      ||.conststring||+0x18
                  zodiac_sign
                          DCD      ||.conststring||+0x1c
                          DCD      ||.conststring||+0x20
                          DCD      ||.conststring||+0x24
                          DCD      ||.conststring||+0x28
                          DCD      ||.conststring||+0x2c
                          DCD      ||.conststring||+0x30
                          DCD      ||.conststring||+0x34
                          DCD      ||.conststring||+0x38
                          DCD      ||.conststring||+0x3c
                          DCD      ||.conststring||+0x40
                          DCD      ||.conststring||+0x44
                          DCD      ||.conststring||+0x48
                  en_WEEK_STR
                          DCD      ||.conststring||+0x4c
                          DCD      ||.conststring||+0x54
                          DCD      ||.conststring||+0x5c
                          DCD      ||.conststring||+0x64
                          DCD      ||.conststring||+0x70
                          DCD      ||.conststring||+0x7c
                          DCD      ||.conststring||+0x84
                  en_zodiac_sign
                          DCD      ||.conststring||+0x90
                          DCD      ||.conststring||+0x94
                          DCD      ||.conststring||+0x98
                          DCD      ||.conststring||+0x9c
                          DCD      ||.conststring||+0xa4
                          DCD      ||.conststring||+0xac
                          DCD      ||.conststring||+0xb4
                          DCD      ||.conststring||+0xbc
                          DCD      ||.conststring||+0xc4
                          DCD      ||.conststring||+0xcc
                          DCD      ||.conststring||+0xd4
                          DCD      ||.conststring||+0xdc

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\rtc\\bsp_rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_rtc_c_e5356c9d____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_bsp_rtc_c_e5356c9d____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_rtc_c_e5356c9d____REVSH|
#line 128
|__asm___9_bsp_rtc_c_e5356c9d____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
