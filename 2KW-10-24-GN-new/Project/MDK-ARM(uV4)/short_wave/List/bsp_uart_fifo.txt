; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\short_wave\obj\bsp_uart_fifo.o --asm_dir=.\short_wave\List\ --list_dir=.\short_wave\List\ --depend=.\short_wave\obj\bsp_uart_fifo.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\adc -I..\..\User\rtc -I..\..\User\internal_flash -I..\..\User\iwdg -I..\..\Task -I..\..\User\can -I..\..\User\firmware_upgrade -I..\..\User\STMFLASH -I..\..\User\IAP -I.\RTE\_Short_Wave -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\short_wave\obj\bsp_uart_fifo.crf ..\..\User\bsp\src\bsp_uart_fifo.c]
                          THUMB

                          AREA ||i.ComToUart||, CODE, READONLY, ALIGN=2

                  ComToUart PROC
;;;89     */
;;;90     UART_T *ComToUart(COM_PORT_E _ucPort)
000000  4601              MOV      r1,r0
;;;91     {
;;;92         if (_ucPort == COM1)
000002  b909              CBNZ     r1,|L1.8|
;;;93         {
;;;94     #if UART1_FIFO_EN == 1
;;;95             return &g_tUart1;
000004  4809              LDR      r0,|L1.44|
                  |L1.6|
;;;96     #else
;;;97             return 0;
;;;98     #endif
;;;99         }
;;;100        else if (_ucPort == COM2)
;;;101        {
;;;102    #if UART2_FIFO_EN == 1
;;;103            return &g_tUart2;
;;;104    #else
;;;105            return 0;
;;;106    #endif
;;;107        }
;;;108        else if (_ucPort == COM3)
;;;109        {
;;;110    #if UART3_FIFO_EN == 1
;;;111            return &g_tUart3;
;;;112    #else
;;;113            return 0;
;;;114    #endif
;;;115        }
;;;116        else if (_ucPort == COM4)
;;;117        {
;;;118    #if UART4_FIFO_EN == 1
;;;119            return &g_tUart4;
;;;120    #else
;;;121            return 0;
;;;122    #endif
;;;123        }
;;;124        else if (_ucPort == COM5)
;;;125        {
;;;126    #if UART5_FIFO_EN == 1
;;;127            return &g_tUart5;
;;;128    #else
;;;129            return 0;
;;;130    #endif
;;;131        }
;;;132        else
;;;133        {
;;;134            /* 不做任何处理 */
;;;135            return 0;
;;;136        }
;;;137    }
000006  4770              BX       lr
                  |L1.8|
000008  2901              CMP      r1,#1                 ;100
00000a  d101              BNE      |L1.16|
00000c  4808              LDR      r0,|L1.48|
00000e  e7fa              B        |L1.6|
                  |L1.16|
000010  2902              CMP      r1,#2                 ;108
000012  d101              BNE      |L1.24|
000014  2000              MOVS     r0,#0                 ;113
000016  e7f6              B        |L1.6|
                  |L1.24|
000018  2903              CMP      r1,#3                 ;116
00001a  d101              BNE      |L1.32|
00001c  4805              LDR      r0,|L1.52|
00001e  e7f2              B        |L1.6|
                  |L1.32|
000020  2904              CMP      r1,#4                 ;124
000022  d101              BNE      |L1.40|
000024  4804              LDR      r0,|L1.56|
000026  e7ee              B        |L1.6|
                  |L1.40|
000028  2000              MOVS     r0,#0                 ;135
00002a  e7ec              B        |L1.6|
;;;138    
                          ENDP

                  |L1.44|
                          DCD      g_tUart1
                  |L1.48|
                          DCD      g_tUart2
                  |L1.52|
                          DCD      g_tUart4
                  |L1.56|
                          DCD      g_tUart5

                          AREA ||i.ConfigUartNVIC||, CODE, READONLY, ALIGN=1

                  ConfigUartNVIC PROC
;;;753    */
;;;754    static void ConfigUartNVIC(void)
000000  b508              PUSH     {r3,lr}
;;;755    {
;;;756        NVIC_InitTypeDef NVIC_InitStructure;
;;;757    
;;;758        /* Configure the NVIC Preemption Priority Bits */
;;;759        /*	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);  --- 在 bsp.c 中 bsp_Init() 中配置中断优先级组 */
;;;760    
;;;761    #if UART1_FIFO_EN == 1
;;;762        /* 使能串口1中断 */
;;;763        NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000002  2025              MOVS     r0,#0x25
000004  f88d0000          STRB     r0,[sp,#0]
;;;764        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 5;
000008  2005              MOVS     r0,#5
00000a  f88d0001          STRB     r0,[sp,#1]
;;;765        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00000e  2000              MOVS     r0,#0
000010  f88d0002          STRB     r0,[sp,#2]
;;;766        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000014  2001              MOVS     r0,#1
000016  f88d0003          STRB     r0,[sp,#3]
;;;767        NVIC_Init(&NVIC_InitStructure);
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       NVIC_Init
;;;768    #endif
;;;769    
;;;770    #if UART2_FIFO_EN == 1
;;;771        /* 使能串口2中断 */
;;;772        NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
000020  2026              MOVS     r0,#0x26
000022  f88d0000          STRB     r0,[sp,#0]
;;;773        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 4;
000026  2004              MOVS     r0,#4
000028  f88d0001          STRB     r0,[sp,#1]
;;;774        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00002c  2000              MOVS     r0,#0
00002e  f88d0002          STRB     r0,[sp,#2]
;;;775        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000032  2001              MOVS     r0,#1
000034  f88d0003          STRB     r0,[sp,#3]
;;;776        NVIC_Init(&NVIC_InitStructure);
000038  4668              MOV      r0,sp
00003a  f7fffffe          BL       NVIC_Init
;;;777    #endif
;;;778    
;;;779    #if UART3_FIFO_EN == 1
;;;780        /* 使能串口3中断t */
;;;781        NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
;;;782        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;
;;;783        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;784        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;785        NVIC_Init(&NVIC_InitStructure);
;;;786    #endif
;;;787    
;;;788    #if UART4_FIFO_EN == 1
;;;789        /* 使能串口4中断t */
;;;790        NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
00003e  2034              MOVS     r0,#0x34
000040  f88d0000          STRB     r0,[sp,#0]
;;;791        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
000044  2002              MOVS     r0,#2
000046  f88d0001          STRB     r0,[sp,#1]
;;;792        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00004a  2000              MOVS     r0,#0
00004c  f88d0002          STRB     r0,[sp,#2]
;;;793        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000050  2001              MOVS     r0,#1
000052  f88d0003          STRB     r0,[sp,#3]
;;;794        NVIC_Init(&NVIC_InitStructure);
000056  4668              MOV      r0,sp
000058  f7fffffe          BL       NVIC_Init
;;;795    #endif
;;;796    
;;;797    #if UART5_FIFO_EN == 1
;;;798        /* 使能串口5中断t */
;;;799        NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQn;
00005c  2035              MOVS     r0,#0x35
00005e  f88d0000          STRB     r0,[sp,#0]
;;;800        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000062  2001              MOVS     r0,#1
000064  f88d0001          STRB     r0,[sp,#1]
;;;801        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000068  2000              MOVS     r0,#0
00006a  f88d0002          STRB     r0,[sp,#2]
;;;802        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00006e  2001              MOVS     r0,#1
000070  f88d0003          STRB     r0,[sp,#3]
;;;803        NVIC_Init(&NVIC_InitStructure);
000074  4668              MOV      r0,sp
000076  f7fffffe          BL       NVIC_Init
;;;804    #endif
;;;805    
;;;806    #if UART6_FIFO_EN == 1
;;;807        /* 使能串口6中断t */
;;;808        NVIC_InitStructure.NVIC_IRQChannel = USART6_IRQn;
;;;809        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;810        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;811        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;812        NVIC_Init(&NVIC_InitStructure);
;;;813    #endif
;;;814    }
00007a  bd08              POP      {r3,pc}
;;;815    
                          ENDP


                          AREA ||i.InitHardUart||, CODE, READONLY, ALIGN=2

                  InitHardUart PROC
;;;507    */
;;;508    static void InitHardUart(void)
000000  b500              PUSH     {lr}
;;;509    {
000002  b085              SUB      sp,sp,#0x14
;;;510        GPIO_InitTypeDef GPIO_InitStructure;
;;;511        USART_InitTypeDef USART_InitStructure;
;;;512    
;;;513    #if UART1_FIFO_EN == 1		/* 串口1 TX = PA9   RX = PA10 或 TX = PB6   RX = PB7*/
;;;514    
;;;515        /* 第1步：打开GPIO和USART部件的时钟 */
;;;516        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000004  2101              MOVS     r1,#1
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;517        RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;518    
;;;519        /* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;520        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000014  f44f7000          MOV      r0,#0x200
000018  f8ad0010          STRH     r0,[sp,#0x10]
;;;521        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001c  2018              MOVS     r0,#0x18
00001e  f88d0013          STRB     r0,[sp,#0x13]
;;;522        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000022  2003              MOVS     r0,#3
000024  f88d0012          STRB     r0,[sp,#0x12]
;;;523        GPIO_Init(GPIOA, &GPIO_InitStructure);
000028  a904              ADD      r1,sp,#0x10
00002a  4879              LDR      r0,|L3.528|
00002c  f7fffffe          BL       GPIO_Init
;;;524    
;;;525        /* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;526        	由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;527        	但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;528        */
;;;529        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000030  f44f6080          MOV      r0,#0x400
000034  f8ad0010          STRH     r0,[sp,#0x10]
;;;530        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000038  2004              MOVS     r0,#4
00003a  f88d0013          STRB     r0,[sp,#0x13]
;;;531        GPIO_Init(GPIOA, &GPIO_InitStructure);
00003e  a904              ADD      r1,sp,#0x10
000040  4873              LDR      r0,|L3.528|
000042  f7fffffe          BL       GPIO_Init
;;;532    
;;;533        /* 第4步： 配置串口硬件参数 */
;;;534        USART_InitStructure.USART_BaudRate = UART1_BAUD;	/* 波特率 */
000046  f44f30e1          MOV      r0,#0x1c200
00004a  9000              STR      r0,[sp,#0]
;;;535        USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00004c  2000              MOVS     r0,#0
00004e  f8ad0004          STRH     r0,[sp,#4]
;;;536        USART_InitStructure.USART_StopBits = USART_StopBits_1;
000052  f8ad0006          STRH     r0,[sp,#6]
;;;537        USART_InitStructure.USART_Parity = USART_Parity_No ;
000056  f8ad0008          STRH     r0,[sp,#8]
;;;538        USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00005a  f8ad000c          STRH     r0,[sp,#0xc]
;;;539        USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00005e  200c              MOVS     r0,#0xc
000060  f8ad000a          STRH     r0,[sp,#0xa]
;;;540        USART_Init(USART1, &USART_InitStructure);
000064  4669              MOV      r1,sp
000066  486b              LDR      r0,|L3.532|
000068  f7fffffe          BL       USART_Init
;;;541    
;;;542        USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
00006c  2201              MOVS     r2,#1
00006e  f2405125          MOV      r1,#0x525
000072  4868              LDR      r0,|L3.532|
000074  f7fffffe          BL       USART_ITConfig
;;;543        /*
;;;544        	USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;545        	注意: 不要在此处打开发送中断
;;;546        	发送中断使能在SendUart()函数打开
;;;547        */
;;;548        USART_Cmd(USART1, ENABLE);		/* 使能串口 */
000078  2101              MOVS     r1,#1
00007a  4866              LDR      r0,|L3.532|
00007c  f7fffffe          BL       USART_Cmd
;;;549    
;;;550        /* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;551        	如下语句解决第1个字节无法正确发送出去的问题 */
;;;552        USART_ClearFlag(USART1, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000080  2140              MOVS     r1,#0x40
000082  4864              LDR      r0,|L3.532|
000084  f7fffffe          BL       USART_ClearFlag
;;;553    #endif
;;;554    
;;;555    
;;;556    
;;;557    #if UART2_FIFO_EN == 1		/* 串口2 TX = PA2， RX = PA3  */
;;;558        /* 第1步：打开GPIO和USART部件的时钟 */
;;;559        //RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_AFIO, ENABLE);TX:D5 RX:D6
;;;560        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000088  2101              MOVS     r1,#1
00008a  2005              MOVS     r0,#5
00008c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;561        RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
000090  2101              MOVS     r1,#1
000092  0448              LSLS     r0,r1,#17
000094  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;562    
;;;563        //	GPIO_PinRemapConfig(GPIO_Remap_USART2, ENABLE); //USART2重映射 PD5 PD6
;;;564    
;;;565        /* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;566        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000098  2004              MOVS     r0,#4
00009a  f8ad0010          STRH     r0,[sp,#0x10]
;;;567        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00009e  2018              MOVS     r0,#0x18
0000a0  f88d0013          STRB     r0,[sp,#0x13]
;;;568        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000a4  2003              MOVS     r0,#3
0000a6  f88d0012          STRB     r0,[sp,#0x12]
;;;569        GPIO_Init(GPIOA, &GPIO_InitStructure);
0000aa  a904              ADD      r1,sp,#0x10
0000ac  4858              LDR      r0,|L3.528|
0000ae  f7fffffe          BL       GPIO_Init
;;;570    
;;;571        /* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;572        	由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;573        	但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;574        */
;;;575        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
0000b2  2008              MOVS     r0,#8
0000b4  f8ad0010          STRH     r0,[sp,#0x10]
;;;576        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
0000b8  2004              MOVS     r0,#4
0000ba  f88d0013          STRB     r0,[sp,#0x13]
;;;577        //GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;578        /*  第3步已经做了，因此这步可以不做
;;;579        	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;580        */
;;;581        GPIO_Init(GPIOA, &GPIO_InitStructure);
0000be  a904              ADD      r1,sp,#0x10
0000c0  4853              LDR      r0,|L3.528|
0000c2  f7fffffe          BL       GPIO_Init
;;;582    
;;;583        /* 第4步： 配置串口硬件参数 */
;;;584        USART_InitStructure.USART_BaudRate = UART2_BAUD;	/* 波特率 */
0000c6  f44f5016          MOV      r0,#0x2580
0000ca  9000              STR      r0,[sp,#0]
;;;585        USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0000cc  2000              MOVS     r0,#0
0000ce  f8ad0004          STRH     r0,[sp,#4]
;;;586        USART_InitStructure.USART_StopBits = USART_StopBits_1;
0000d2  f8ad0006          STRH     r0,[sp,#6]
;;;587        USART_InitStructure.USART_Parity = USART_Parity_No ;
0000d6  f8ad0008          STRH     r0,[sp,#8]
;;;588        USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
0000da  f8ad000c          STRH     r0,[sp,#0xc]
;;;589        USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;		/* 仅选择接收模式 */
0000de  200c              MOVS     r0,#0xc
0000e0  f8ad000a          STRH     r0,[sp,#0xa]
;;;590        USART_Init(USART2, &USART_InitStructure);
0000e4  4669              MOV      r1,sp
0000e6  484c              LDR      r0,|L3.536|
0000e8  f7fffffe          BL       USART_Init
;;;591    
;;;592        USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
0000ec  2201              MOVS     r2,#1
0000ee  f2405125          MOV      r1,#0x525
0000f2  4849              LDR      r0,|L3.536|
0000f4  f7fffffe          BL       USART_ITConfig
;;;593        /*
;;;594        	USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;595        	注意: 不要在此处打开发送中断
;;;596        	发送中断使能在SendUart()函数打开
;;;597        */
;;;598        USART_Cmd(USART2, ENABLE);		/* 使能串口 */
0000f8  2101              MOVS     r1,#1
0000fa  4847              LDR      r0,|L3.536|
0000fc  f7fffffe          BL       USART_Cmd
;;;599    
;;;600        /* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;601        	如下语句解决第1个字节无法正确发送出去的问题 */
;;;602        USART_ClearFlag(USART2, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000100  2140              MOVS     r1,#0x40
000102  4845              LDR      r0,|L3.536|
000104  f7fffffe          BL       USART_ClearFlag
;;;603    #endif
;;;604    
;;;605    
;;;606    #if UART3_FIFO_EN == 1			/* 串口3 TX = PB10   RX = PB11 */
;;;607    
;;;608        /* 配置 PB2为推挽输出，用于切换 RS485芯片的收发状态 */
;;;609        {
;;;610            RCC_APB2PeriphClockCmd(RCC_RS485_TXEN, ENABLE);
;;;611    
;;;612            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
;;;613            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;614            GPIO_InitStructure.GPIO_Pin = PIN_RS485_TXEN;
;;;615            GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
;;;616        }
;;;617    
;;;618        /* 第1步： 开启GPIO和UART时钟 */
;;;619        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
;;;620        RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
;;;621    
;;;622        /* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;623        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
;;;624        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;625        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;626        GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;627    
;;;628        /* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;629        	由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;630        	但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;631        */
;;;632        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
;;;633        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;634        GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;635        /*  第3步已经做了，因此这步可以不做
;;;636        	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;637        */
;;;638        GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;639    
;;;640        /* 第4步： 配置串口硬件参数 */
;;;641        USART_InitStructure.USART_BaudRate = UART3_BAUD;	/* 波特率 */
;;;642        USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;643        USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;644        USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;645        USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;646        USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;647        USART_Init(USART3, &USART_InitStructure);
;;;648    
;;;649        USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;650        /*
;;;651        	USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;652        	注意: 不要在此处打开发送中断
;;;653        	发送中断使能在SendUart()函数打开
;;;654        */
;;;655        USART_Cmd(USART3, ENABLE);		/* 使能串口 */
;;;656    
;;;657        /* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;658        	如下语句解决第1个字节无法正确发送出去的问题 */
;;;659        USART_ClearFlag(USART3, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;660    #endif
;;;661    
;;;662    #if UART4_FIFO_EN == 1			/* 串口4 TX = PC10   RX = PC11 */
;;;663        /* 第1步： 开启GPIO和UART时钟 */
;;;664        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);
000108  2101              MOVS     r1,#1
00010a  2011              MOVS     r0,#0x11
00010c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;665        RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
000110  2101              MOVS     r1,#1
000112  04c8              LSLS     r0,r1,#19
000114  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;666    
;;;667        /* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;668        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000118  f44f6080          MOV      r0,#0x400
00011c  f8ad0010          STRH     r0,[sp,#0x10]
;;;669        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000120  2018              MOVS     r0,#0x18
000122  f88d0013          STRB     r0,[sp,#0x13]
;;;670        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000126  2003              MOVS     r0,#3
000128  f88d0012          STRB     r0,[sp,#0x12]
;;;671        GPIO_Init(GPIOC, &GPIO_InitStructure);
00012c  a904              ADD      r1,sp,#0x10
00012e  483b              LDR      r0,|L3.540|
000130  f7fffffe          BL       GPIO_Init
;;;672    
;;;673        /* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;674        	由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;675        	但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;676        */
;;;677        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
000134  f44f6000          MOV      r0,#0x800
000138  f8ad0010          STRH     r0,[sp,#0x10]
;;;678        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00013c  2004              MOVS     r0,#4
00013e  f88d0013          STRB     r0,[sp,#0x13]
;;;679        GPIO_Init(GPIOC, &GPIO_InitStructure);
000142  a904              ADD      r1,sp,#0x10
000144  4835              LDR      r0,|L3.540|
000146  f7fffffe          BL       GPIO_Init
;;;680    
;;;681        /* 第4步： 配置串口硬件参数 */
;;;682        USART_InitStructure.USART_BaudRate = UART4_BAUD;	/* 波特率 */
00014a  f44f5016          MOV      r0,#0x2580
00014e  9000              STR      r0,[sp,#0]
;;;683        USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000150  2000              MOVS     r0,#0
000152  f8ad0004          STRH     r0,[sp,#4]
;;;684        USART_InitStructure.USART_StopBits = USART_StopBits_1;
000156  f8ad0006          STRH     r0,[sp,#6]
;;;685        USART_InitStructure.USART_Parity = USART_Parity_No ;
00015a  f8ad0008          STRH     r0,[sp,#8]
;;;686        USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00015e  f8ad000c          STRH     r0,[sp,#0xc]
;;;687        USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000162  200c              MOVS     r0,#0xc
000164  f8ad000a          STRH     r0,[sp,#0xa]
;;;688        USART_Init(UART4, &USART_InitStructure);
000168  4669              MOV      r1,sp
00016a  482d              LDR      r0,|L3.544|
00016c  f7fffffe          BL       USART_Init
;;;689    
;;;690        USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
000170  2201              MOVS     r2,#1
000172  f2405125          MOV      r1,#0x525
000176  482a              LDR      r0,|L3.544|
000178  f7fffffe          BL       USART_ITConfig
;;;691        /*
;;;692        	USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;693        	注意: 不要在此处打开发送中断
;;;694        	发送中断使能在SendUart()函数打开
;;;695        */
;;;696        USART_Cmd(UART4, ENABLE);		/* 使能串口 */
00017c  2101              MOVS     r1,#1
00017e  4828              LDR      r0,|L3.544|
000180  f7fffffe          BL       USART_Cmd
;;;697    
;;;698        /* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;699        	如下语句解决第1个字节无法正确发送出去的问题 */
;;;700        USART_ClearFlag(UART4, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000184  2140              MOVS     r1,#0x40
000186  4826              LDR      r0,|L3.544|
000188  f7fffffe          BL       USART_ClearFlag
;;;701    #endif
;;;702    
;;;703    #if UART5_FIFO_EN == 1			/* 串口5 TX = PC12   RX = PD2 */
;;;704        /* 第1步： 开启GPIO和UART时钟 */
;;;705        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_AFIO, ENABLE);
00018c  2101              MOVS     r1,#1
00018e  2031              MOVS     r0,#0x31
000190  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;706        RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);
000194  2101              MOVS     r1,#1
000196  0508              LSLS     r0,r1,#20
000198  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;707    
;;;708        /* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;709        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
00019c  f44f5080          MOV      r0,#0x1000
0001a0  f8ad0010          STRH     r0,[sp,#0x10]
;;;710        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
0001a4  2018              MOVS     r0,#0x18
0001a6  f88d0013          STRB     r0,[sp,#0x13]
;;;711        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0001aa  2003              MOVS     r0,#3
0001ac  f88d0012          STRB     r0,[sp,#0x12]
;;;712        GPIO_Init(GPIOC, &GPIO_InitStructure);
0001b0  a904              ADD      r1,sp,#0x10
0001b2  481a              LDR      r0,|L3.540|
0001b4  f7fffffe          BL       GPIO_Init
;;;713    
;;;714        /* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;715        	由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;716        	但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;717        */
;;;718        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
0001b8  2004              MOVS     r0,#4
0001ba  f8ad0010          STRH     r0,[sp,#0x10]
;;;719        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
0001be  f88d0013          STRB     r0,[sp,#0x13]
;;;720        GPIO_Init(GPIOD, &GPIO_InitStructure);
0001c2  a904              ADD      r1,sp,#0x10
0001c4  4817              LDR      r0,|L3.548|
0001c6  f7fffffe          BL       GPIO_Init
;;;721    
;;;722    
;;;723        /* 第4步： 配置串口硬件参数 */
;;;724        USART_InitStructure.USART_BaudRate = UART5_BAUD;	/* 波特率 */
0001ca  f44f5016          MOV      r0,#0x2580
0001ce  9000              STR      r0,[sp,#0]
;;;725        USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0001d0  2000              MOVS     r0,#0
0001d2  f8ad0004          STRH     r0,[sp,#4]
;;;726        USART_InitStructure.USART_StopBits = USART_StopBits_1;
0001d6  f8ad0006          STRH     r0,[sp,#6]
;;;727        USART_InitStructure.USART_Parity = USART_Parity_No ;
0001da  f8ad0008          STRH     r0,[sp,#8]
;;;728        USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
0001de  f8ad000c          STRH     r0,[sp,#0xc]
;;;729        USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
0001e2  200c              MOVS     r0,#0xc
0001e4  f8ad000a          STRH     r0,[sp,#0xa]
;;;730        USART_Init(UART5, &USART_InitStructure);
0001e8  4669              MOV      r1,sp
0001ea  480f              LDR      r0,|L3.552|
0001ec  f7fffffe          BL       USART_Init
;;;731    
;;;732        USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
0001f0  2201              MOVS     r2,#1
0001f2  f2405125          MOV      r1,#0x525
0001f6  480c              LDR      r0,|L3.552|
0001f8  f7fffffe          BL       USART_ITConfig
;;;733        /*
;;;734        	USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;735        	注意: 不要在此处打开发送中断
;;;736        	发送中断使能在SendUart()函数打开
;;;737        */
;;;738        USART_Cmd(UART5, ENABLE);		/* 使能串口 */
0001fc  2101              MOVS     r1,#1
0001fe  480a              LDR      r0,|L3.552|
000200  f7fffffe          BL       USART_Cmd
;;;739    
;;;740        /* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;741        	如下语句解决第1个字节无法正确发送出去的问题 */
;;;742        USART_ClearFlag(UART5, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000204  2140              MOVS     r1,#0x40
000206  4808              LDR      r0,|L3.552|
000208  f7fffffe          BL       USART_ClearFlag
;;;743    #endif
;;;744    }
00020c  b005              ADD      sp,sp,#0x14
00020e  bd00              POP      {pc}
;;;745    
                          ENDP

                  |L3.528|
                          DCD      0x40010800
                  |L3.532|
                          DCD      0x40013800
                  |L3.536|
                          DCD      0x40004400
                  |L3.540|
                          DCD      0x40011000
                  |L3.544|
                          DCD      0x40004c00
                  |L3.548|
                          DCD      0x40011400
                  |L3.552|
                          DCD      0x40005000

                          AREA ||i.RS485_ReciveNew||, CODE, READONLY, ALIGN=1

                  RS485_ReciveNew PROC
;;;380    //extern void MODBUS_ReciveNew(uint8_t _byte);
;;;381    void RS485_ReciveNew(uint8_t _byte)
000000  4770              BX       lr
;;;382    {
;;;383    //	MODBUS_ReciveNew(_byte);
;;;384    }
;;;385    
                          ENDP


                          AREA ||i.RS485_SendBefor||, CODE, READONLY, ALIGN=2

                  RS485_SendBefor PROC
;;;323    */
;;;324    void RS485_SendBefor(void)
000000  2004              MOVS     r0,#4
;;;325    {
;;;326        RS485_TX_EN();	/* 切换RS485收发芯片为发送模式 */
000002  4901              LDR      r1,|L5.8|
000004  6008              STR      r0,[r1,#0]
;;;327    }
000006  4770              BX       lr
;;;328    
                          ENDP

                  |L5.8|
                          DCD      0x40010c10

                          AREA ||i.RS485_SendBuf||, CODE, READONLY, ALIGN=1

                  RS485_SendBuf PROC
;;;351    */
;;;352    void RS485_SendBuf(uint8_t *_ucaBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;353    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;354        comSendBuf(COM3, _ucaBuf, _usLen);
000006  462a              MOV      r2,r5
000008  4621              MOV      r1,r4
00000a  2002              MOVS     r0,#2
00000c  f7fffffe          BL       comSendBuf
;;;355    }
000010  bd70              POP      {r4-r6,pc}
;;;356    
                          ENDP


                          AREA ||i.RS485_SendOver||, CODE, READONLY, ALIGN=2

                  RS485_SendOver PROC
;;;337    */
;;;338    void RS485_SendOver(void)
000000  2004              MOVS     r0,#4
;;;339    {
;;;340        RS485_RX_EN();	/* 切换RS485收发芯片为接收模式 */
000002  4901              LDR      r1,|L7.8|
000004  6008              STR      r0,[r1,#0]
;;;341    }
000006  4770              BX       lr
;;;342    
                          ENDP

                  |L7.8|
                          DCD      0x40010c14

                          AREA ||i.RS485_SendStr||, CODE, READONLY, ALIGN=1

                  RS485_SendStr PROC
;;;366    */
;;;367    void RS485_SendStr(char *_pBuf)
000000  b570              PUSH     {r4-r6,lr}
;;;368    {
000002  4604              MOV      r4,r0
;;;369        RS485_SendBuf((uint8_t *)_pBuf, strlen(_pBuf));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       strlen
00000a  b285              UXTH     r5,r0
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       RS485_SendBuf
;;;370    }
000014  bd70              POP      {r4-r6,pc}
;;;371    
                          ENDP


                          AREA ||i.UART4_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART4_IRQHandler PROC
;;;1048   #if UART4_FIFO_EN == 1
;;;1049   void UART4_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1050   {
;;;1051       UartIRQ(&g_tUart4);
000002  4802              LDR      r0,|L9.12|
000004  f7fffffe          BL       UartIRQ
;;;1052   }
000008  bd10              POP      {r4,pc}
;;;1053   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      g_tUart4

                          AREA ||i.UART5_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART5_IRQHandler PROC
;;;1055   #if UART5_FIFO_EN == 1
;;;1056   void UART5_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1057   {
;;;1058       UartIRQ(&g_tUart5);
000002  4802              LDR      r0,|L10.12|
000004  f7fffffe          BL       UartIRQ
;;;1059   }
000008  bd10              POP      {r4,pc}
;;;1060   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      g_tUart5

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;1027   #if UART1_FIFO_EN == 1
;;;1028   void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1029   {
;;;1030       UartIRQ(&g_tUart1);
000002  4802              LDR      r0,|L11.12|
000004  f7fffffe          BL       UartIRQ
;;;1031   }
000008  bd10              POP      {r4,pc}
;;;1032   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      g_tUart1

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;1034   #if UART2_FIFO_EN == 1
;;;1035   void USART2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1036   {
;;;1037       UartIRQ(&g_tUart2);
000002  4802              LDR      r0,|L12.12|
000004  f7fffffe          BL       UartIRQ
;;;1038   }
000008  bd10              POP      {r4,pc}
;;;1039   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      g_tUart2

                          AREA ||i.UartGetChar||, CODE, READONLY, ALIGN=1

                  UartGetChar PROC
;;;895    */
;;;896    static uint8_t UartGetChar(UART_T *_pUart, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;897    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;898        uint16_t usCount;
;;;899    
;;;900        /* usRxWrite 变量在中断函数中被改写，主程序读取该变量时，必须进行临界区保护 */
;;;901        DISABLE_INT();
000006  f7fffffe          BL       vPortEnterCritical
;;;902        usCount = _pUart->usRxCount;
00000a  8b66              LDRH     r6,[r4,#0x1a]
;;;903        ENABLE_INT();
00000c  f7fffffe          BL       vPortExitCritical
;;;904    
;;;905        /* 如果读和写索引相同，则返回0 */
;;;906        //if (_pUart->usRxRead == usRxWrite)
;;;907        if (usCount == 0)	/* 已经没有数据 */
000010  b90e              CBNZ     r6,|L13.22|
;;;908        {
;;;909            return 0;
000012  2000              MOVS     r0,#0
                  |L13.20|
;;;910        }
;;;911        else
;;;912        {
;;;913            *_pByte = _pUart->pRxBuf[_pUart->usRxRead];		/* 从串口接收FIFO取1个数据 */
;;;914    
;;;915            /* 改写FIFO读索引 */
;;;916            DISABLE_INT();
;;;917            if (++_pUart->usRxRead >= _pUart->usRxBufSize)
;;;918            {
;;;919                _pUart->usRxRead = 0;
;;;920            }
;;;921            _pUart->usRxCount--;
;;;922            ENABLE_INT();
;;;923            return 1;
;;;924        }
;;;925    }
000014  bd70              POP      {r4-r6,pc}
                  |L13.22|
000016  68a0              LDR      r0,[r4,#8]            ;913
000018  8b21              LDRH     r1,[r4,#0x18]         ;913
00001a  5c40              LDRB     r0,[r0,r1]            ;913
00001c  7028              STRB     r0,[r5,#0]            ;913
00001e  f7fffffe          BL       vPortEnterCritical
000022  8b20              LDRH     r0,[r4,#0x18]         ;917
000024  1c40              ADDS     r0,r0,#1              ;917
000026  b280              UXTH     r0,r0                 ;917
000028  8320              STRH     r0,[r4,#0x18]         ;917
00002a  89e1              LDRH     r1,[r4,#0xe]          ;917
00002c  4288              CMP      r0,r1                 ;917
00002e  db01              BLT      |L13.52|
000030  2000              MOVS     r0,#0                 ;919
000032  8320              STRH     r0,[r4,#0x18]         ;919
                  |L13.52|
000034  8b60              LDRH     r0,[r4,#0x1a]         ;921
000036  1e40              SUBS     r0,r0,#1              ;921
000038  8360              STRH     r0,[r4,#0x1a]         ;921
00003a  f7fffffe          BL       vPortExitCritical
00003e  2001              MOVS     r0,#1                 ;923
000040  e7e8              B        |L13.20|
;;;926    
                          ENDP


                          AREA ||i.UartIRQ||, CODE, READONLY, ALIGN=1

                  UartIRQ PROC
;;;934    */
;;;935    static void UartIRQ(UART_T *_pUart)
000000  b570              PUSH     {r4-r6,lr}
;;;936    {
000002  4604              MOV      r4,r0
;;;937        /* 处理接收中断  */
;;;938        if (USART_GetITStatus(_pUart->uart, USART_IT_RXNE) != RESET)
000004  6820              LDR      r0,[r4,#0]
000006  f2405125          MOV      r1,#0x525
00000a  f7fffffe          BL       USART_GetITStatus
00000e  b1e0              CBZ      r0,|L14.74|
;;;939        {
;;;940            /* 从串口接收数据寄存器读取数据存放到接收FIFO */
;;;941            uint8_t ch;
;;;942    
;;;943            ch = USART_ReceiveData(_pUart->uart);
000010  6820              LDR      r0,[r4,#0]
000012  f7fffffe          BL       USART_ReceiveData
000016  b2c5              UXTB     r5,r0
;;;944            _pUart->pRxBuf[_pUart->usRxWrite] = ch;
000018  68a0              LDR      r0,[r4,#8]
00001a  8ae1              LDRH     r1,[r4,#0x16]
00001c  5445              STRB     r5,[r0,r1]
;;;945            if (++_pUart->usRxWrite >= _pUart->usRxBufSize)
00001e  8ae0              LDRH     r0,[r4,#0x16]
000020  1c40              ADDS     r0,r0,#1
000022  b280              UXTH     r0,r0
000024  82e0              STRH     r0,[r4,#0x16]
000026  89e1              LDRH     r1,[r4,#0xe]
000028  4288              CMP      r0,r1
00002a  db01              BLT      |L14.48|
;;;946            {
;;;947                _pUart->usRxWrite = 0;
00002c  2000              MOVS     r0,#0
00002e  82e0              STRH     r0,[r4,#0x16]
                  |L14.48|
;;;948            }
;;;949            if (_pUart->usRxCount < _pUart->usRxBufSize)
000030  8b60              LDRH     r0,[r4,#0x1a]
000032  89e1              LDRH     r1,[r4,#0xe]
000034  4288              CMP      r0,r1
000036  da02              BGE      |L14.62|
;;;950            {
;;;951                _pUart->usRxCount++;
000038  8b60              LDRH     r0,[r4,#0x1a]
00003a  1c40              ADDS     r0,r0,#1
00003c  8360              STRH     r0,[r4,#0x1a]
                  |L14.62|
;;;952            }
;;;953    
;;;954            /* 回调函数,通知应用程序收到新数据,一般是发送1个消息或者设置一个标记 */
;;;955            //if (_pUart->usRxWrite == _pUart->usRxRead)
;;;956            //if (_pUart->usRxCount == 1)
;;;957            {
;;;958                if (_pUart->ReciveNew)
00003e  6a60              LDR      r0,[r4,#0x24]
000040  b110              CBZ      r0,|L14.72|
;;;959                {
;;;960                    _pUart->ReciveNew(ch);
000042  6a61              LDR      r1,[r4,#0x24]
000044  4628              MOV      r0,r5
000046  4788              BLX      r1
                  |L14.72|
;;;961                }
;;;962            }
;;;963        }
000048  bf00              NOP      
                  |L14.74|
;;;964    
;;;965        /* 处理发送缓冲区空中断 */
;;;966        if (USART_GetITStatus(_pUart->uart, USART_IT_TXE) != RESET)
00004a  6820              LDR      r0,[r4,#0]
00004c  f2407127          MOV      r1,#0x727
000050  f7fffffe          BL       USART_GetITStatus
000054  b308              CBZ      r0,|L14.154|
;;;967        {
;;;968            //if (_pUart->usTxRead == _pUart->usTxWrite)
;;;969            if (_pUart->usTxCount == 0)
000056  8aa0              LDRH     r0,[r4,#0x14]
000058  b960              CBNZ     r0,|L14.116|
;;;970            {
;;;971                /* 发送缓冲区的数据已取完时， 禁止发送缓冲区空中断 （注意：此时最后1个数据还未真正发送完毕）*/
;;;972                USART_ITConfig(_pUart->uart, USART_IT_TXE, DISABLE);
00005a  6820              LDR      r0,[r4,#0]
00005c  2200              MOVS     r2,#0
00005e  f2407127          MOV      r1,#0x727
000062  f7fffffe          BL       USART_ITConfig
;;;973    
;;;974                /* 使能数据发送完毕中断 */
;;;975                USART_ITConfig(_pUart->uart, USART_IT_TC, ENABLE);
000066  6820              LDR      r0,[r4,#0]
000068  2201              MOVS     r2,#1
00006a  f2406126          MOV      r1,#0x626
00006e  f7fffffe          BL       USART_ITConfig
000072  e037              B        |L14.228|
                  |L14.116|
;;;976            }
;;;977            else
;;;978            {
;;;979                /* 从发送FIFO取1个字节写入串口发送数据寄存器 */
;;;980                USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
000074  6862              LDR      r2,[r4,#4]
000076  8a63              LDRH     r3,[r4,#0x12]
000078  5cd1              LDRB     r1,[r2,r3]
00007a  6820              LDR      r0,[r4,#0]
00007c  f7fffffe          BL       USART_SendData
;;;981                if (++_pUart->usTxRead >= _pUart->usTxBufSize)
000080  8a60              LDRH     r0,[r4,#0x12]
000082  1c40              ADDS     r0,r0,#1
000084  b280              UXTH     r0,r0
000086  8260              STRH     r0,[r4,#0x12]
000088  89a1              LDRH     r1,[r4,#0xc]
00008a  4288              CMP      r0,r1
00008c  db01              BLT      |L14.146|
;;;982                {
;;;983                    _pUart->usTxRead = 0;
00008e  2000              MOVS     r0,#0
000090  8260              STRH     r0,[r4,#0x12]
                  |L14.146|
;;;984                }
;;;985                _pUart->usTxCount--;
000092  8aa0              LDRH     r0,[r4,#0x14]
000094  1e40              SUBS     r0,r0,#1
000096  82a0              STRH     r0,[r4,#0x14]
000098  e024              B        |L14.228|
                  |L14.154|
;;;986            }
;;;987    
;;;988        }
;;;989        /* 数据bit位全部发送完毕的中断 */
;;;990        else if (USART_GetITStatus(_pUart->uart, USART_IT_TC) != RESET)
00009a  6820              LDR      r0,[r4,#0]
00009c  f2406126          MOV      r1,#0x626
0000a0  f7fffffe          BL       USART_GetITStatus
0000a4  b1f0              CBZ      r0,|L14.228|
;;;991        {
;;;992            //if (_pUart->usTxRead == _pUart->usTxWrite)
;;;993            if (_pUart->usTxCount == 0)
0000a6  8aa0              LDRH     r0,[r4,#0x14]
0000a8  b950              CBNZ     r0,|L14.192|
;;;994            {
;;;995                /* 如果发送FIFO的数据全部发送完毕，禁止数据发送完毕中断 */
;;;996                USART_ITConfig(_pUart->uart, USART_IT_TC, DISABLE);
0000aa  6820              LDR      r0,[r4,#0]
0000ac  2200              MOVS     r2,#0
0000ae  f2406126          MOV      r1,#0x626
0000b2  f7fffffe          BL       USART_ITConfig
;;;997    
;;;998                /* 回调函数, 一般用来处理RS485通信，将RS485芯片设置为接收模式，避免抢占总线 */
;;;999                if (_pUart->SendOver)
0000b6  6a20              LDR      r0,[r4,#0x20]
0000b8  b1a0              CBZ      r0,|L14.228|
;;;1000               {
;;;1001                   _pUart->SendOver();
0000ba  6a20              LDR      r0,[r4,#0x20]
0000bc  4780              BLX      r0
0000be  e011              B        |L14.228|
                  |L14.192|
;;;1002               }
;;;1003           }
;;;1004           else
;;;1005           {
;;;1006               /* 正常情况下，不会进入此分支 */
;;;1007   
;;;1008               /* 如果发送FIFO的数据还未完毕，则从发送FIFO取1个数据写入发送数据寄存器 */
;;;1009               USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
0000c0  6862              LDR      r2,[r4,#4]
0000c2  8a63              LDRH     r3,[r4,#0x12]
0000c4  5cd1              LDRB     r1,[r2,r3]
0000c6  6820              LDR      r0,[r4,#0]
0000c8  f7fffffe          BL       USART_SendData
;;;1010               if (++_pUart->usTxRead >= _pUart->usTxBufSize)
0000cc  8a60              LDRH     r0,[r4,#0x12]
0000ce  1c40              ADDS     r0,r0,#1
0000d0  b280              UXTH     r0,r0
0000d2  8260              STRH     r0,[r4,#0x12]
0000d4  89a1              LDRH     r1,[r4,#0xc]
0000d6  4288              CMP      r0,r1
0000d8  db01              BLT      |L14.222|
;;;1011               {
;;;1012                   _pUart->usTxRead = 0;
0000da  2000              MOVS     r0,#0
0000dc  8260              STRH     r0,[r4,#0x12]
                  |L14.222|
;;;1013               }
;;;1014               _pUart->usTxCount--;
0000de  8aa0              LDRH     r0,[r4,#0x14]
0000e0  1e40              SUBS     r0,r0,#1
0000e2  82a0              STRH     r0,[r4,#0x14]
                  |L14.228|
;;;1015           }
;;;1016       }
;;;1017   }
0000e4  bd70              POP      {r4-r6,pc}
;;;1018   
                          ENDP


                          AREA ||i.UartSend||, CODE, READONLY, ALIGN=1

                  UartSend PROC
;;;823    */
;;;824    static void UartSend(UART_T *_pUart, uint8_t *_ucaBuf, uint16_t _usLen)
000000  b5f8              PUSH     {r3-r7,lr}
;;;825    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;826        uint16_t i;
;;;827    
;;;828        for (i = 0; i < _usLen; i++)
000008  2500              MOVS     r5,#0
00000a  e025              B        |L15.88|
                  |L15.12|
;;;829        {
;;;830            /* 如果发送缓冲区已经满了，则等待缓冲区空 */
;;;831    #if 0
;;;832            /*
;;;833            	在调试GPRS例程时，下面的代码出现死机，while 死循环
;;;834            	原因： 发送第1个字节时 _pUart->usTxWrite = 1；_pUart->usTxRead = 0;
;;;835            	将导致while(1) 无法退出
;;;836            */
;;;837            while (1)
;;;838            {
;;;839                uint16_t usRead;
;;;840    
;;;841                DISABLE_INT();
;;;842                usRead = _pUart->usTxRead;
;;;843                ENABLE_INT();
;;;844    
;;;845                if (++usRead >= _pUart->usTxBufSize)
;;;846                {
;;;847                    usRead = 0;
;;;848                }
;;;849    
;;;850                if (usRead != _pUart->usTxWrite)
;;;851                {
;;;852                    break;
;;;853                }
;;;854            }
;;;855    #else
;;;856            /* 当 _pUart->usTxBufSize == 1 时, 下面的函数会死掉(待完善) */
;;;857            while (1)
00000c  e00c              B        |L15.40|
                  |L15.14|
;;;858            {
;;;859                __IO uint16_t usCount;
;;;860    
;;;861                DISABLE_INT();
00000e  f7fffffe          BL       vPortEnterCritical
;;;862                usCount = _pUart->usTxCount;
000012  8aa0              LDRH     r0,[r4,#0x14]
000014  9000              STR      r0,[sp,#0]
;;;863                ENABLE_INT();
000016  f7fffffe          BL       vPortExitCritical
;;;864    
;;;865                if (usCount < _pUart->usTxBufSize)
00001a  89a0              LDRH     r0,[r4,#0xc]
00001c  f8bd1000          LDRH     r1,[sp,#0]
000020  4288              CMP      r0,r1
000022  dd00              BLE      |L15.38|
;;;866                {
;;;867                    break;
000024  e001              B        |L15.42|
                  |L15.38|
;;;868                }
;;;869            }
000026  bf00              NOP      
                  |L15.40|
000028  e7f1              B        |L15.14|
                  |L15.42|
00002a  bf00              NOP                            ;867
;;;870    #endif
;;;871    
;;;872            /* 将新数据填入发送缓冲区 */
;;;873            _pUart->pTxBuf[_pUart->usTxWrite] = _ucaBuf[i];
00002c  5d70              LDRB     r0,[r6,r5]
00002e  6861              LDR      r1,[r4,#4]
000030  8a22              LDRH     r2,[r4,#0x10]
000032  5488              STRB     r0,[r1,r2]
;;;874    
;;;875            DISABLE_INT();
000034  f7fffffe          BL       vPortEnterCritical
;;;876            if (++_pUart->usTxWrite >= _pUart->usTxBufSize)
000038  8a20              LDRH     r0,[r4,#0x10]
00003a  1c40              ADDS     r0,r0,#1
00003c  b280              UXTH     r0,r0
00003e  8220              STRH     r0,[r4,#0x10]
000040  89a1              LDRH     r1,[r4,#0xc]
000042  4288              CMP      r0,r1
000044  db01              BLT      |L15.74|
;;;877            {
;;;878                _pUart->usTxWrite = 0;
000046  2000              MOVS     r0,#0
000048  8220              STRH     r0,[r4,#0x10]
                  |L15.74|
;;;879            }
;;;880            _pUart->usTxCount++;
00004a  8aa0              LDRH     r0,[r4,#0x14]
00004c  1c40              ADDS     r0,r0,#1
00004e  82a0              STRH     r0,[r4,#0x14]
;;;881            ENABLE_INT();
000050  f7fffffe          BL       vPortExitCritical
000054  1c68              ADDS     r0,r5,#1              ;828
000056  b285              UXTH     r5,r0                 ;828
                  |L15.88|
000058  42bd              CMP      r5,r7                 ;828
00005a  dbd7              BLT      |L15.12|
;;;882        }
;;;883    
;;;884        USART_ITConfig(_pUart->uart, USART_IT_TXE, ENABLE);
00005c  6820              LDR      r0,[r4,#0]
00005e  2201              MOVS     r2,#1
000060  f2407127          MOV      r1,#0x727
000064  f7fffffe          BL       USART_ITConfig
;;;885    }
000068  bdf8              POP      {r3-r7,pc}
;;;886    
                          ENDP


                          AREA ||i.UartVarInit||, CODE, READONLY, ALIGN=2

                  UartVarInit PROC
;;;393    */
;;;394    static void UartVarInit(void)
000000  482a              LDR      r0,|L16.172|
;;;395    {
;;;396    #if UART1_FIFO_EN == 1
;;;397        g_tUart1.uart = USART1;						/* STM32 串口设备 */
000002  492b              LDR      r1,|L16.176|
000004  6008              STR      r0,[r1,#0]  ; g_tUart1
;;;398        g_tUart1.pTxBuf = g_TxBuf1;					/* 发送缓冲区指针 */
000006  482b              LDR      r0,|L16.180|
000008  6048              STR      r0,[r1,#4]  ; g_tUart1
;;;399        g_tUart1.pRxBuf = g_RxBuf1;					/* 接收缓冲区指针 */
00000a  482b              LDR      r0,|L16.184|
00000c  6088              STR      r0,[r1,#8]  ; g_tUart1
;;;400        g_tUart1.usTxBufSize = UART1_TX_BUF_SIZE;	/* 发送缓冲区大小 */
00000e  f44f6080          MOV      r0,#0x400
000012  8188              STRH     r0,[r1,#0xc]
;;;401        g_tUart1.usRxBufSize = UART1_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000014  1080              ASRS     r0,r0,#2
000016  81c8              STRH     r0,[r1,#0xe]
;;;402        g_tUart1.usTxWrite = 0;						/* 发送FIFO写索引 */
000018  2000              MOVS     r0,#0
00001a  8208              STRH     r0,[r1,#0x10]
;;;403        g_tUart1.usTxRead = 0;						/* 发送FIFO读索引 */
00001c  8248              STRH     r0,[r1,#0x12]
;;;404        g_tUart1.usRxWrite = 0;						/* 接收FIFO写索引 */
00001e  82c8              STRH     r0,[r1,#0x16]
;;;405        g_tUart1.usRxRead = 0;						/* 接收FIFO读索引 */
000020  8308              STRH     r0,[r1,#0x18]
;;;406        g_tUart1.usRxCount = 0;						/* 接收到的新数据个数 */
000022  8348              STRH     r0,[r1,#0x1a]
;;;407        g_tUart1.usTxCount = 0;						/* 待发送的数据个数 */
000024  8288              STRH     r0,[r1,#0x14]
;;;408        g_tUart1.SendBefor = 0;						/* 发送数据前的回调函数 */
000026  61c8              STR      r0,[r1,#0x1c]  ; g_tUart1
;;;409        g_tUart1.SendOver = 0;						/* 发送完毕后的回调函数 */
000028  6208              STR      r0,[r1,#0x20]  ; g_tUart1
;;;410        g_tUart1.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
00002a  6248              STR      r0,[r1,#0x24]  ; g_tUart1
;;;411    #endif
;;;412    
;;;413    #if UART2_FIFO_EN == 1
;;;414        g_tUart2.uart = USART2;						/* STM32 串口设备 */
00002c  4823              LDR      r0,|L16.188|
00002e  4924              LDR      r1,|L16.192|
000030  6008              STR      r0,[r1,#0]  ; g_tUart2
;;;415        g_tUart2.pTxBuf = g_TxBuf2;					/* 发送缓冲区指针 */
000032  4824              LDR      r0,|L16.196|
000034  6048              STR      r0,[r1,#4]  ; g_tUart2
;;;416        g_tUart2.pRxBuf = g_RxBuf2;					/* 接收缓冲区指针 */
000036  4824              LDR      r0,|L16.200|
000038  6088              STR      r0,[r1,#8]  ; g_tUart2
;;;417        g_tUart2.usTxBufSize = UART2_TX_BUF_SIZE;	/* 发送缓冲区大小 */
00003a  f44f7080          MOV      r0,#0x100
00003e  8188              STRH     r0,[r1,#0xc]
;;;418        g_tUart2.usRxBufSize = UART2_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000040  81c8              STRH     r0,[r1,#0xe]
;;;419        g_tUart2.usTxWrite = 0;						/* 发送FIFO写索引 */
000042  2000              MOVS     r0,#0
000044  8208              STRH     r0,[r1,#0x10]
;;;420        g_tUart2.usTxRead = 0;						/* 发送FIFO读索引 */
000046  8248              STRH     r0,[r1,#0x12]
;;;421        g_tUart2.usRxWrite = 0;						/* 接收FIFO写索引 */
000048  82c8              STRH     r0,[r1,#0x16]
;;;422        g_tUart2.usRxRead = 0;						/* 接收FIFO读索引 */
00004a  8308              STRH     r0,[r1,#0x18]
;;;423        g_tUart2.usRxCount = 0;						/* 接收到的新数据个数 */
00004c  8348              STRH     r0,[r1,#0x1a]
;;;424        g_tUart2.usTxCount = 0;						/* 待发送的数据个数 */
00004e  8288              STRH     r0,[r1,#0x14]
;;;425        g_tUart2.SendBefor = 0;						/* 发送数据前的回调函数 */
000050  61c8              STR      r0,[r1,#0x1c]  ; g_tUart2
;;;426        g_tUart2.SendOver = 0;						/* 发送完毕后的回调函数 */
000052  6208              STR      r0,[r1,#0x20]  ; g_tUart2
;;;427        g_tUart2.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
000054  6248              STR      r0,[r1,#0x24]  ; g_tUart2
;;;428    #endif
;;;429    
;;;430    #if UART3_FIFO_EN == 1
;;;431        g_tUart3.uart = USART3;						/* STM32 串口设备 */
;;;432        g_tUart3.pTxBuf = g_TxBuf3;					/* 发送缓冲区指针 */
;;;433        g_tUart3.pRxBuf = g_RxBuf3;					/* 接收缓冲区指针 */
;;;434        g_tUart3.usTxBufSize = UART3_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;435        g_tUart3.usRxBufSize = UART3_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;436        g_tUart3.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;437        g_tUart3.usTxRead = 0;						/* 发送FIFO读索引 */
;;;438        g_tUart3.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;439        g_tUart3.usRxRead = 0;						/* 接收FIFO读索引 */
;;;440        g_tUart3.usRxCount = 0;						/* 接收到的新数据个数 */
;;;441        g_tUart3.usTxCount = 0;						/* 待发送的数据个数 */
;;;442        g_tUart3.SendBefor = RS485_SendBefor;		/* 发送数据前的回调函数 */
;;;443        g_tUart3.SendOver = RS485_SendOver;			/* 发送完毕后的回调函数 */
;;;444        g_tUart3.ReciveNew = RS485_ReciveNew;		/* 接收到新数据后的回调函数 */
;;;445    #endif
;;;446    
;;;447    #if UART4_FIFO_EN == 1
;;;448        g_tUart4.uart = UART4;						/* STM32 串口设备 */
000056  481d              LDR      r0,|L16.204|
000058  491d              LDR      r1,|L16.208|
00005a  6008              STR      r0,[r1,#0]  ; g_tUart4
;;;449        g_tUart4.pTxBuf = g_TxBuf4;					/* 发送缓冲区指针 */
00005c  481d              LDR      r0,|L16.212|
00005e  6048              STR      r0,[r1,#4]  ; g_tUart4
;;;450        g_tUart4.pRxBuf = g_RxBuf4;					/* 接收缓冲区指针 */
000060  481d              LDR      r0,|L16.216|
000062  6088              STR      r0,[r1,#8]  ; g_tUart4
;;;451        g_tUart4.usTxBufSize = UART4_TX_BUF_SIZE;	/* 发送缓冲区大小 */
000064  f44f7000          MOV      r0,#0x200
000068  8188              STRH     r0,[r1,#0xc]
;;;452        g_tUart4.usRxBufSize = UART4_RX_BUF_SIZE;	/* 接收缓冲区大小 */
00006a  81c8              STRH     r0,[r1,#0xe]
;;;453        g_tUart4.usTxWrite = 0;						/* 发送FIFO写索引 */
00006c  2000              MOVS     r0,#0
00006e  8208              STRH     r0,[r1,#0x10]
;;;454        g_tUart4.usTxRead = 0;						/* 发送FIFO读索引 */
000070  8248              STRH     r0,[r1,#0x12]
;;;455        g_tUart4.usRxWrite = 0;						/* 接收FIFO写索引 */
000072  82c8              STRH     r0,[r1,#0x16]
;;;456        g_tUart4.usRxRead = 0;						/* 接收FIFO读索引 */
000074  8308              STRH     r0,[r1,#0x18]
;;;457        g_tUart4.usRxCount = 0;						/* 接收到的新数据个数 */
000076  8348              STRH     r0,[r1,#0x1a]
;;;458        g_tUart4.usTxCount = 0;						/* 待发送的数据个数 */
000078  8288              STRH     r0,[r1,#0x14]
;;;459        g_tUart4.SendBefor = 0;						/* 发送数据前的回调函数 */
00007a  61c8              STR      r0,[r1,#0x1c]  ; g_tUart4
;;;460        g_tUart4.SendOver = 0;						/* 发送完毕后的回调函数 */
00007c  6208              STR      r0,[r1,#0x20]  ; g_tUart4
;;;461        g_tUart4.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
00007e  6248              STR      r0,[r1,#0x24]  ; g_tUart4
;;;462    #endif
;;;463    
;;;464    #if UART5_FIFO_EN == 1
;;;465        g_tUart5.uart = UART5;						/* STM32 串口设备 */
000080  4816              LDR      r0,|L16.220|
000082  4917              LDR      r1,|L16.224|
000084  6008              STR      r0,[r1,#0]  ; g_tUart5
;;;466        g_tUart5.pTxBuf = g_TxBuf5;					/* 发送缓冲区指针 */
000086  4817              LDR      r0,|L16.228|
000088  6048              STR      r0,[r1,#4]  ; g_tUart5
;;;467        g_tUart5.pRxBuf = g_RxBuf5;					/* 接收缓冲区指针 */
00008a  4817              LDR      r0,|L16.232|
00008c  6088              STR      r0,[r1,#8]  ; g_tUart5
;;;468        g_tUart5.usTxBufSize = UART5_TX_BUF_SIZE;	/* 发送缓冲区大小 */
00008e  f44f7080          MOV      r0,#0x100
000092  8188              STRH     r0,[r1,#0xc]
;;;469        g_tUart5.usRxBufSize = UART5_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000094  81c8              STRH     r0,[r1,#0xe]
;;;470        g_tUart5.usTxWrite = 0;						/* 发送FIFO写索引 */
000096  2000              MOVS     r0,#0
000098  8208              STRH     r0,[r1,#0x10]
;;;471        g_tUart5.usTxRead = 0;						/* 发送FIFO读索引 */
00009a  8248              STRH     r0,[r1,#0x12]
;;;472        g_tUart5.usRxWrite = 0;						/* 接收FIFO写索引 */
00009c  82c8              STRH     r0,[r1,#0x16]
;;;473        g_tUart5.usRxRead = 0;						/* 接收FIFO读索引 */
00009e  8308              STRH     r0,[r1,#0x18]
;;;474        g_tUart5.usRxCount = 0;						/* 接收到的新数据个数 */
0000a0  8348              STRH     r0,[r1,#0x1a]
;;;475        g_tUart5.usTxCount = 0;						/* 待发送的数据个数 */
0000a2  8288              STRH     r0,[r1,#0x14]
;;;476        g_tUart5.SendBefor = 0;						/* 发送数据前的回调函数 */
0000a4  61c8              STR      r0,[r1,#0x1c]  ; g_tUart5
;;;477        g_tUart5.SendOver = 0;						/* 发送完毕后的回调函数 */
0000a6  6208              STR      r0,[r1,#0x20]  ; g_tUart5
;;;478        g_tUart5.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
0000a8  6248              STR      r0,[r1,#0x24]  ; g_tUart5
;;;479    #endif
;;;480    
;;;481    
;;;482    #if UART6_FIFO_EN == 1
;;;483        g_tUart6.uart = USART6;						/* STM32 串口设备 */
;;;484        g_tUart6.pTxBuf = g_TxBuf6;					/* 发送缓冲区指针 */
;;;485        g_tUart6.pRxBuf = g_RxBuf6;					/* 接收缓冲区指针 */
;;;486        g_tUart6.usTxBufSize = UART6_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;487        g_tUart6.usRxBufSize = UART6_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;488        g_tUart6.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;489        g_tUart6.usTxRead = 0;						/* 发送FIFO读索引 */
;;;490        g_tUart6.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;491        g_tUart6.usRxRead = 0;						/* 接收FIFO读索引 */
;;;492        g_tUart6.usRxCount = 0;						/* 接收到的新数据个数 */
;;;493        g_tUart6.usTxCount = 0;						/* 待发送的数据个数 */
;;;494        g_tUart6.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;495        g_tUart6.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;496        g_tUart6.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;497    #endif
;;;498    }
0000aa  4770              BX       lr
;;;499    
                          ENDP

                  |L16.172|
                          DCD      0x40013800
                  |L16.176|
                          DCD      g_tUart1
                  |L16.180|
                          DCD      g_TxBuf1
                  |L16.184|
                          DCD      g_RxBuf1
                  |L16.188|
                          DCD      0x40004400
                  |L16.192|
                          DCD      g_tUart2
                  |L16.196|
                          DCD      g_TxBuf2
                  |L16.200|
                          DCD      g_RxBuf2
                  |L16.204|
                          DCD      0x40004c00
                  |L16.208|
                          DCD      g_tUart4
                  |L16.212|
                          DCD      g_TxBuf4
                  |L16.216|
                          DCD      g_RxBuf4
                  |L16.220|
                          DCD      0x40005000
                  |L16.224|
                          DCD      g_tUart5
                  |L16.228|
                          DCD      g_TxBuf5
                  |L16.232|
                          DCD      g_RxBuf5

                          AREA ||i.bsp_InitUart||, CODE, READONLY, ALIGN=1

                  bsp_InitUart PROC
;;;72     */
;;;73     void bsp_InitUart(void)
000000  b510              PUSH     {r4,lr}
;;;74     {
;;;75         UartVarInit();		/* 必须先初始化全局变量,再配置硬件 */
000002  f7fffffe          BL       UartVarInit
;;;76     
;;;77         InitHardUart();		/* 配置串口的硬件参数(波特率等) */
000006  f7fffffe          BL       InitHardUart
;;;78     
;;;79         ConfigUartNVIC();	/* 配置串口中断 */
00000a  f7fffffe          BL       ConfigUartNVIC
;;;80     }
00000e  bd10              POP      {r4,pc}
;;;81     
                          ENDP


                          AREA ||i.bsp_Set485Baud||, CODE, READONLY, ALIGN=2

                  bsp_Set485Baud PROC
;;;300    */
;;;301    void bsp_Set485Baud(uint32_t _baud)
000000  b51f              PUSH     {r0-r4,lr}
;;;302    {
000002  4604              MOV      r4,r0
;;;303        USART_InitTypeDef USART_InitStructure;
;;;304    
;;;305        /* 第2步： 配置串口硬件参数 */
;;;306        USART_InitStructure.USART_BaudRate = _baud;	/* 波特率 */
000004  9400              STR      r4,[sp,#0]
;;;307        USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000006  2000              MOVS     r0,#0
000008  f8ad0004          STRH     r0,[sp,#4]
;;;308        USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000c  f8ad0006          STRH     r0,[sp,#6]
;;;309        USART_InitStructure.USART_Parity = USART_Parity_No ;
000010  f8ad0008          STRH     r0,[sp,#8]
;;;310        USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000014  f8ad000c          STRH     r0,[sp,#0xc]
;;;311        USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000018  200c              MOVS     r0,#0xc
00001a  f8ad000a          STRH     r0,[sp,#0xa]
;;;312        USART_Init(USART3, &USART_InitStructure);
00001e  4669              MOV      r1,sp
000020  4801              LDR      r0,|L18.40|
000022  f7fffffe          BL       USART_Init
;;;313    }
000026  bd1f              POP      {r0-r4,pc}
;;;314    
                          ENDP

                  |L18.40|
                          DCD      0x40004800

                          AREA ||i.bsp_SetUart1Baud||, CODE, READONLY, ALIGN=2

                  bsp_SetUart1Baud PROC
;;;256    */
;;;257    void bsp_SetUart1Baud(uint32_t _baud)
000000  b51f              PUSH     {r0-r4,lr}
;;;258    {
000002  4604              MOV      r4,r0
;;;259        USART_InitTypeDef USART_InitStructure;
;;;260    
;;;261        /* 第2步： 配置串口硬件参数 */
;;;262        USART_InitStructure.USART_BaudRate = _baud;	/* 波特率 */
000004  9400              STR      r4,[sp,#0]
;;;263        USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000006  2000              MOVS     r0,#0
000008  f8ad0004          STRH     r0,[sp,#4]
;;;264        USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000c  f8ad0006          STRH     r0,[sp,#6]
;;;265        USART_InitStructure.USART_Parity = USART_Parity_No ;
000010  f8ad0008          STRH     r0,[sp,#8]
;;;266        USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000014  f8ad000c          STRH     r0,[sp,#0xc]
;;;267        USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000018  200c              MOVS     r0,#0xc
00001a  f8ad000a          STRH     r0,[sp,#0xa]
;;;268        USART_Init(USART2, &USART_InitStructure);
00001e  4669              MOV      r1,sp
000020  4801              LDR      r0,|L19.40|
000022  f7fffffe          BL       USART_Init
;;;269    }
000026  bd1f              POP      {r0-r4,pc}
;;;270    
                          ENDP

                  |L19.40|
                          DCD      0x40004400

                          AREA ||i.bsp_SetUart2Baud||, CODE, READONLY, ALIGN=2

                  bsp_SetUart2Baud PROC
;;;278    */
;;;279    void bsp_SetUart2Baud(uint32_t _baud)
000000  b51f              PUSH     {r0-r4,lr}
;;;280    {
000002  4604              MOV      r4,r0
;;;281        USART_InitTypeDef USART_InitStructure;
;;;282    
;;;283        /* 第2步： 配置串口硬件参数 */
;;;284        USART_InitStructure.USART_BaudRate = _baud;	/* 波特率 */
000004  9400              STR      r4,[sp,#0]
;;;285        USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000006  2000              MOVS     r0,#0
000008  f8ad0004          STRH     r0,[sp,#4]
;;;286        USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000c  f8ad0006          STRH     r0,[sp,#6]
;;;287        USART_InitStructure.USART_Parity = USART_Parity_No ;
000010  f8ad0008          STRH     r0,[sp,#8]
;;;288        USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000014  f8ad000c          STRH     r0,[sp,#0xc]
;;;289        USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000018  200c              MOVS     r0,#0xc
00001a  f8ad000a          STRH     r0,[sp,#0xa]
;;;290        USART_Init(USART2, &USART_InitStructure);
00001e  4669              MOV      r1,sp
000020  4801              LDR      r0,|L20.40|
000022  f7fffffe          BL       USART_Init
;;;291    }
000026  bd1f              POP      {r0-r4,pc}
;;;292    
                          ENDP

                  |L20.40|
                          DCD      0x40004400

                          AREA ||i.comClearRxFifo||, CODE, READONLY, ALIGN=1

                  comClearRxFifo PROC
;;;233    */
;;;234    void comClearRxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;235    {
000002  4603              MOV      r3,r0
;;;236        UART_T *pUart;
;;;237    
;;;238        pUart = ComToUart(_ucPort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       ComToUart
00000a  4602              MOV      r2,r0
;;;239        if (pUart == 0)
00000c  b902              CBNZ     r2,|L21.16|
                  |L21.14|
;;;240        {
;;;241            return;
;;;242        }
;;;243    
;;;244        pUart->usRxWrite = 0;
;;;245        pUart->usRxRead = 0;
;;;246        pUart->usRxCount = 0;
;;;247    }
00000e  bd00              POP      {pc}
                  |L21.16|
000010  2000              MOVS     r0,#0                 ;244
000012  82d0              STRH     r0,[r2,#0x16]         ;244
000014  8310              STRH     r0,[r2,#0x18]         ;245
000016  8350              STRH     r0,[r2,#0x1a]         ;246
000018  bf00              NOP      
00001a  e7f8              B        |L21.14|
;;;248    
                          ENDP


                          AREA ||i.comClearTxFifo||, CODE, READONLY, ALIGN=1

                  comClearTxFifo PROC
;;;210    */
;;;211    void comClearTxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;212    {
000002  4603              MOV      r3,r0
;;;213        UART_T *pUart;
;;;214    
;;;215        pUart = ComToUart(_ucPort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       ComToUart
00000a  4602              MOV      r2,r0
;;;216        if (pUart == 0)
00000c  b902              CBNZ     r2,|L22.16|
                  |L22.14|
;;;217        {
;;;218            return;
;;;219        }
;;;220    
;;;221        pUart->usTxWrite = 0;
;;;222        pUart->usTxRead = 0;
;;;223        pUart->usTxCount = 0;
;;;224    }
00000e  bd00              POP      {pc}
                  |L22.16|
000010  2000              MOVS     r0,#0                 ;221
000012  8210              STRH     r0,[r2,#0x10]         ;221
000014  8250              STRH     r0,[r2,#0x12]         ;222
000016  8290              STRH     r0,[r2,#0x14]         ;223
000018  bf00              NOP      
00001a  e7f8              B        |L22.14|
;;;225    
                          ENDP


                          AREA ||i.comGetChar||, CODE, READONLY, ALIGN=1

                  comGetChar PROC
;;;189    */
;;;190    uint8_t comGetChar(COM_PORT_E _ucPort, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;191    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;192        UART_T *pUart;
;;;193    
;;;194        pUart = ComToUart(_ucPort);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       ComToUart
00000c  4604              MOV      r4,r0
;;;195        if (pUart == 0)
00000e  b90c              CBNZ     r4,|L23.20|
;;;196        {
;;;197            return 0;
000010  2000              MOVS     r0,#0
                  |L23.18|
;;;198        }
;;;199    
;;;200        return UartGetChar(pUart, _pByte);
;;;201    }
000012  bd70              POP      {r4-r6,pc}
                  |L23.20|
000014  4631              MOV      r1,r6                 ;200
000016  4620              MOV      r0,r4                 ;200
000018  f7fffffe          BL       UartGetChar
00001c  e7f9              B        |L23.18|
;;;202    
                          ENDP


                          AREA ||i.comSendBuf||, CODE, READONLY, ALIGN=1

                  comSendBuf PROC
;;;148    */
;;;149    void comSendBuf(COM_PORT_E _ucPort, uint8_t *_ucaBuf, uint16_t _usLen)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;150    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;151        UART_T *pUart;
;;;152    
;;;153        pUart = ComToUart(_ucPort);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       ComToUart
000010  4604              MOV      r4,r0
;;;154        if (pUart == 0)
000012  b90c              CBNZ     r4,|L24.24|
                  |L24.20|
;;;155        {
;;;156            return;
;;;157        }
;;;158    
;;;159        if (pUart->SendBefor != 0)
;;;160        {
;;;161            pUart->SendBefor();		/* 如果是RS485通信，可以在这个函数中将RS485设置为发送模式 */
;;;162        }
;;;163    
;;;164        UartSend(pUart, _ucaBuf, _usLen);
;;;165    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L24.24|
000018  69e0              LDR      r0,[r4,#0x1c]         ;159
00001a  b108              CBZ      r0,|L24.32|
00001c  69e0              LDR      r0,[r4,#0x1c]         ;161
00001e  4780              BLX      r0                    ;161
                  |L24.32|
000020  463a              MOV      r2,r7                 ;164
000022  4631              MOV      r1,r6                 ;164
000024  4620              MOV      r0,r4                 ;164
000026  f7fffffe          BL       UartSend
00002a  bf00              NOP      
00002c  e7f2              B        |L24.20|
;;;166    
                          ENDP


                          AREA ||i.comSendChar||, CODE, READONLY, ALIGN=1

                  comSendChar PROC
;;;175    */
;;;176    void comSendChar(COM_PORT_E _ucPort, uint8_t _ucByte)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;177    {
000002  4604              MOV      r4,r0
;;;178        comSendBuf(_ucPort, &_ucByte, 1);
000004  2201              MOVS     r2,#1
000006  a901              ADD      r1,sp,#4
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       comSendBuf
;;;179    }
00000e  bd1c              POP      {r2-r4,pc}
;;;180    
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;1102   */
;;;1103   int fgetc(FILE *f)
000000  b538              PUSH     {r3-r5,lr}
;;;1104   {
000002  4604              MOV      r4,r0
;;;1105   
;;;1106   #if 1	/* 从串口接收FIFO中取1个数据, 只有取到数据才返回 */
;;;1107       uint8_t ucData;
;;;1108   
;;;1109       while(comGetChar(COM1, &ucData) == 0);
000004  bf00              NOP      
                  |L26.6|
000006  4669              MOV      r1,sp
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       comGetChar
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L26.6|
;;;1110   
;;;1111       return ucData;
000012  f89d0000          LDRB     r0,[sp,#0]
;;;1112   #else
;;;1113       /* 等待串口1输入数据 */
;;;1114       while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);
;;;1115   
;;;1116       return (int)USART_ReceiveData(USART1);
;;;1117   #endif
;;;1118   }
000016  bd38              POP      {r3-r5,pc}
;;;1119   
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;1076   */
;;;1077   int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;1078   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1079   #if 1	/* 将需要printf的字符通过串口中断FIFO发送出去，printf函数会立即返回 */
;;;1080       comSendChar(COM1, ch);
000006  b2e1              UXTB     r1,r4
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       comSendChar
;;;1081   
;;;1082       return ch;
00000e  4620              MOV      r0,r4
;;;1083   #else	/* 采用阻塞方式发送每个字符,等待数据发送完毕 */
;;;1084       /* 写一个字节到USART1 */
;;;1085       USART_SendData(USART1, (uint8_t) ch);
;;;1086   
;;;1087       /* 等待发送结束 */
;;;1088       while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
;;;1089       {}
;;;1090   
;;;1091       return ch;
;;;1092   #endif
;;;1093   }
000010  bd70              POP      {r4-r6,pc}
;;;1094   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_tUart1
                          %        40
                  g_TxBuf1
                          %        1024
                  g_RxBuf1
                          %        256
                  g_tUart2
                          %        40
                  g_TxBuf2
                          %        256
                  g_RxBuf2
                          %        256
                  g_tUart4
                          %        40
                  g_TxBuf4
                          %        512
                  g_RxBuf4
                          %        512
                  g_tUart5
                          %        40
                  g_TxBuf5
                          %        256
                  g_RxBuf5
                          %        256

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_uart_fifo.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_uart_fifo_c_b28b0d00____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH|
#line 128
|__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
