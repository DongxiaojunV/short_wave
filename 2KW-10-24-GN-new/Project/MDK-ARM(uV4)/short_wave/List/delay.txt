; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\short_wave\obj\delay.o --asm_dir=.\short_wave\List\ --list_dir=.\short_wave\List\ --depend=.\short_wave\obj\delay.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\adc -I..\..\User\rtc -I..\..\User\internal_flash -I..\..\User\iwdg -I..\..\Task -I..\..\User\can -I..\..\User\firmware_upgrade -I..\..\User\STMFLASH -I..\..\User\IAP -I.\RTE\_Short_Wave -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\short_wave\obj\delay.crf ..\..\User\delay.c]
                          THUMB

                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=1

                  SysTick_Handler PROC
;;;14     //systick中断服务函数,使用ucos时用到
;;;15     void SysTick_Handler(void)
000000  b510              PUSH     {r4,lr}
;;;16     {	
;;;17         if(xTaskGetSchedulerState()!=taskSCHEDULER_NOT_STARTED)//系统已经运行
000002  f7fffffe          BL       xTaskGetSchedulerState
000006  2801              CMP      r0,#1
000008  d003              BEQ      |L1.18|
;;;18         {
;;;19             xPortSysTickHandler();	
00000a  e8bd4010          POP      {r4,lr}
00000e  f7ffbffe          B.W      xPortSysTickHandler
                  |L1.18|
;;;20         }
;;;21     }
000012  bd10              POP      {r4,pc}
;;;22     		   
                          ENDP


                          AREA ||i.delay_init||, CODE, READONLY, ALIGN=2

                  delay_init PROC
;;;26     //SYSCLK:系统时钟频率
;;;27     void delay_init()
000000  b510              PUSH     {r4,lr}
;;;28     {
;;;29     	u32 reload;
;;;30     	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);//选择外部时钟  HCLK
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       SysTick_CLKSourceConfig
;;;31     	fac_us=SystemCoreClock/1000000;				//不论是否使用OS,fac_us都需要使用
000008  480c              LDR      r0,|L2.60|
00000a  490d              LDR      r1,|L2.64|
00000c  4a0d              LDR      r2,|L2.68|
00000e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000010  fbb0f3f1          UDIV     r3,r0,r1
000014  7013              STRB     r3,[r2,#0]
;;;32     	reload=SystemCoreClock/1000000;				//每秒钟的计数次数 单位为M  
000016  fbb0f1f1          UDIV     r1,r0,r1
;;;33     	reload*=1000000/configTICK_RATE_HZ;			//根据configTICK_RATE_HZ设定溢出时间
00001a  f44f707a          MOV      r0,#0x3e8
00001e  4341              MULS     r1,r0,r1
;;;34     												//reload为24位寄存器,最大值:16777216,在72M下,约合0.233s左右	
;;;35     	fac_ms=1000/configTICK_RATE_HZ;				//代表OS可以延时的最少单位	   
000020  2001              MOVS     r0,#1
000022  8050              STRH     r0,[r2,#2]
;;;36     
;;;37     	SysTick->CTRL|=SysTick_CTRL_TICKINT_Msk;   	//开启SYSTICK中断
000024  f04f20e0          MOV      r0,#0xe000e000
000028  6902              LDR      r2,[r0,#0x10]
00002a  f0420202          ORR      r2,r2,#2
00002e  6102              STR      r2,[r0,#0x10]
;;;38     	SysTick->LOAD=reload; 						//每1/configTICK_RATE_HZ秒中断一次	
000030  6141              STR      r1,[r0,#0x14]
;;;39     	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk;   	//开启SYSTICK    
000032  6901              LDR      r1,[r0,#0x10]
000034  f0410101          ORR      r1,r1,#1
000038  6101              STR      r1,[r0,#0x10]
;;;40     }								    
00003a  bd10              POP      {r4,pc}
;;;41     
                          ENDP

                  |L2.60|
                          DCD      SystemCoreClock
                  |L2.64|
                          DCD      0x000f4240
                  |L2.68|
                          DCD      ||.data||

                          AREA ||i.delay_ms||, CODE, READONLY, ALIGN=2

                  delay_ms PROC
;;;67     //nms:0~65535
;;;68     void delay_ms(u32 nms)
000000  b570              PUSH     {r4-r6,lr}
;;;69     {	
000002  4604              MOV      r4,r0
;;;70     	if(xTaskGetSchedulerState()!=taskSCHEDULER_NOT_STARTED)//系统已经运行
000004  f7fffffe          BL       xTaskGetSchedulerState
000008  2801              CMP      r0,#1
00000a  d00c              BEQ      |L3.38|
;;;71     	{		
;;;72     		if(nms>=fac_ms)						//延时的时间大于OS的最少时间周期 
00000c  4d09              LDR      r5,|L3.52|
00000e  8868              LDRH     r0,[r5,#2]  ; fac_ms
000010  4284              CMP      r4,r0
000012  d303              BCC      |L3.28|
;;;73     		{ 
;;;74        			vTaskDelay(nms/fac_ms);	 		//FreeRTOS延时
000014  fbb4f0f0          UDIV     r0,r4,r0
000018  f7fffffe          BL       vTaskDelay
                  |L3.28|
;;;75     		}
;;;76     		nms%=fac_ms;						//OS已经无法提供这么小的延时了,采用普通方式延时    
00001c  8868              LDRH     r0,[r5,#2]  ; fac_ms
00001e  fbb4f1f0          UDIV     r1,r4,r0
000022  fb004411          MLS      r4,r0,r1,r4
                  |L3.38|
;;;77     	}
;;;78     	delay_us((u32)(nms*1000));				//普通方式延时
000026  f44f707a          MOV      r0,#0x3e8
00002a  4360              MULS     r0,r4,r0
00002c  e8bd4070          POP      {r4-r6,lr}
000030  f7ffbffe          B.W      delay_us
;;;79     }
;;;80     
                          ENDP

                  |L3.52|
                          DCD      ||.data||

                          AREA ||i.delay_us||, CODE, READONLY, ALIGN=2

                  delay_us PROC
;;;45     //nus:0~204522252(最大值即2^32/fac_us@fac_us=168)	    								   
;;;46     void delay_us(u32 nus)
000000  b570              PUSH     {r4-r6,lr}
;;;47     {		
;;;48     	u32 ticks;
;;;49     	u32 told,tnow,tcnt=0;
000002  2100              MOVS     r1,#0
;;;50     	u32 reload=SysTick->LOAD;				//LOAD的值	    	 
000004  f04f25e0          MOV      r5,#0xe000e000
000008  696c              LDR      r4,[r5,#0x14]
;;;51     	ticks=nus*fac_us; 						//需要的节拍数 
00000a  4a0a              LDR      r2,|L4.52|
00000c  7812              LDRB     r2,[r2,#0]  ; fac_us
00000e  4350              MULS     r0,r2,r0
;;;52     	told=SysTick->VAL;        				//刚进入时的计数器值
000010  69ab              LDR      r3,[r5,#0x18]
                  |L4.18|
;;;53     	while(1)
;;;54     	{
;;;55     		tnow=SysTick->VAL;	
000012  69aa              LDR      r2,[r5,#0x18]
;;;56     		if(tnow!=told)
000014  429a              CMP      r2,r3
000016  d0fc              BEQ      |L4.18|
;;;57     		{	    
;;;58     			if(tnow<told)tcnt+=told-tnow;	//这里注意一下SYSTICK是一个递减的计数器就可以了.
000018  d203              BCS      |L4.34|
00001a  eba30302          SUB      r3,r3,r2
00001e  4419              ADD      r1,r1,r3
000020  e003              B        |L4.42|
                  |L4.34|
;;;59     			else tcnt+=reload-tnow+told;	    
000022  eba40602          SUB      r6,r4,r2
000026  4433              ADD      r3,r3,r6
000028  4419              ADD      r1,r1,r3
                  |L4.42|
;;;60     			told=tnow;
00002a  4613              MOV      r3,r2
;;;61     			if(tcnt>=ticks)break;			//时间超过/等于要延迟的时间,则退出.
00002c  4281              CMP      r1,r0
00002e  d3f0              BCC      |L4.18|
;;;62     		}  
;;;63     	};										    
;;;64     }  
000030  bd70              POP      {r4-r6,pc}
;;;65     //延时nms
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      ||.data||

                          AREA ||i.delay_xms||, CODE, READONLY, ALIGN=1

                  delay_xms PROC
;;;82     //nms:要延时的ms数
;;;83     void delay_xms(u32 nms)
000000  b570              PUSH     {r4-r6,lr}
;;;84     {
000002  4605              MOV      r5,r0
;;;85     	u32 i;
;;;86     	for(i=0;i<nms;i++) delay_us(1000);
000004  2400              MOVS     r4,#0
000006  f44f767a          MOV      r6,#0x3e8
00000a  e003              B        |L5.20|
                  |L5.12|
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       delay_us
000012  1c64              ADDS     r4,r4,#1
                  |L5.20|
000014  42ac              CMP      r4,r5
000016  d3f9              BCC      |L5.12|
;;;87     }
000018  bd70              POP      {r4-r6,pc}
;;;88     
                          ENDP


                          AREA ||.data||, DATA, ALIGN=1

                  fac_us
000000  0000              DCB      0x00,0x00
                  fac_ms
000002  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\delay.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_delay_c_b672aa62____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_delay_c_b672aa62____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_delay_c_b672aa62____REVSH|
#line 128
|__asm___7_delay_c_b672aa62____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
