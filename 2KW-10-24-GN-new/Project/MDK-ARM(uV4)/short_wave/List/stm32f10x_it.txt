; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\short_wave\obj\stm32f10x_it.o --asm_dir=.\short_wave\List\ --list_dir=.\short_wave\List\ --depend=.\short_wave\obj\stm32f10x_it.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\adc -I..\..\User\rtc -I..\..\User\internal_flash -I..\..\User\iwdg -I..\..\Task -I..\..\User\can -I..\..\User\firmware_upgrade -I..\..\User\STMFLASH -I..\..\User\IAP -I.\RTE\_Short_Wave -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\short_wave\obj\stm32f10x_it.crf ..\..\User\bsp\stm32f10x_it.c]
                          THUMB

                          AREA ||i.BusFault_Handler||, CODE, READONLY, ALIGN=1

                  BusFault_Handler PROC
;;;106    */
;;;107    void BusFault_Handler(void)
000000  bf00              NOP      
                  |L1.2|
;;;108    {
;;;109        /* 当总线异常时进入死循环 */
;;;110        while (1)
000002  e7fe              B        |L1.2|
;;;111        {
;;;112        }
;;;113    }
;;;114    
                          ENDP


                          AREA ||i.DebugMon_Handler||, CODE, READONLY, ALIGN=1

                  DebugMon_Handler PROC
;;;138    */
;;;139    void DebugMon_Handler(void)
000000  4770              BX       lr
;;;140    {
;;;141    }
;;;142    
                          ENDP


                          AREA ||i.HardFault_Handler||, CODE, READONLY, ALIGN=2

                  HardFault_Handler PROC
;;;59     */
;;;60     void HardFault_Handler(void)
000000  a50c              ADR      r5,|L3.52|
;;;61     {
;;;62     #if 1
;;;63         const char *pError = ERR_INFO;
;;;64         uint8_t i;
;;;65     
;;;66         for (i = 0; i < sizeof(ERR_INFO); i++)
000002  2400              MOVS     r4,#0
000004  e00c              B        |L3.32|
                  |L3.6|
;;;67         {
;;;68             USART1->DR = pError[i];
000006  5d28              LDRB     r0,[r5,r4]
000008  4916              LDR      r1,|L3.100|
00000a  8008              STRH     r0,[r1,#0]
;;;69             /* 等待发送结束 */
;;;70             while ((USART1->SR & USART_FLAG_TC) == (uint16_t)RESET);
00000c  bf00              NOP      
                  |L3.14|
00000e  4815              LDR      r0,|L3.100|
000010  1f00              SUBS     r0,r0,#4
000012  8800              LDRH     r0,[r0,#0]
000014  f0000040          AND      r0,r0,#0x40
000018  2800              CMP      r0,#0
00001a  d0f8              BEQ      |L3.14|
00001c  1c60              ADDS     r0,r4,#1              ;66
00001e  b2c4              UXTB     r4,r0                 ;66
                  |L3.32|
000020  2c2f              CMP      r4,#0x2f              ;66
000022  d3f0              BCC      |L3.6|
;;;71         }
;;;72     
;;;73         LED1_OFF;
000024  2008              MOVS     r0,#8
000026  4910              LDR      r1,|L3.104|
000028  6008              STR      r0,[r1,#0]
;;;74     
;;;75         BootLoad_Jump_Recover();
00002a  f7fffffe          BL       BootLoad_Jump_Recover
;;;76     #endif
;;;77         /* 当硬件失效异常发生时进入死循环 */
;;;78         while (1)
00002e  bf00              NOP      
                  |L3.48|
000030  e7fe              B        |L3.48|
;;;79         {
;;;80         }
;;;81     }
;;;82     
                          ENDP

000032  0000              DCW      0x0000
                  |L3.52|
000034  0d0a456e          DCB      "\r\nEnter HardFault_Handler, System Haldfault.\r\n",0
000038  74657220
00003c  48617264
000040  4661756c
000044  745f4861
000048  6e646c65
00004c  722c2053
000050  79737465
000054  6d204861
000058  6c646661
00005c  756c742e
000060  0d0a00  
000063  00                DCB      0
                  |L3.100|
                          DCD      0x40013804
                  |L3.104|
                          DCD      0x40010c10

                          AREA ||i.MemManage_Handler||, CODE, READONLY, ALIGN=1

                  MemManage_Handler PROC
;;;90     */
;;;91     void MemManage_Handler(void)
000000  bf00              NOP      
                  |L4.2|
;;;92     {
;;;93         /* 当内存管理异常发生时进入死循环 */
;;;94         while (1)
000002  e7fe              B        |L4.2|
;;;95         {
;;;96         }
;;;97     }
;;;98     
                          ENDP


                          AREA ||i.NMI_Handler||, CODE, READONLY, ALIGN=1

                  NMI_Handler PROC
;;;47     */
;;;48     void NMI_Handler(void)
000000  4770              BX       lr
;;;49     {
;;;50     }
;;;51     
                          ENDP


                          AREA ||i.RTC_IRQHandler||, CODE, READONLY, ALIGN=1

                  RTC_IRQHandler PROC
;;;142    
;;;143    void RTC_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;144    {
;;;145        if (RTC_GetITStatus(RTC_IT_SEC) != RESET)
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       RTC_GetITStatus
000008  b120              CBZ      r0,|L6.20|
;;;146        {
;;;147            /* Clear the RTC Second interrupt */
;;;148            RTC_ClearITPendingBit(RTC_IT_SEC);
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       RTC_ClearITPendingBit
;;;149    
;;;150            /* Enable time update */
;;;151            // TimeDisplay = 1;
;;;152    
;;;153            /* Wait until last write operation on RTC registers has finished */
;;;154            RTC_WaitForLastTask();
000010  f7fffffe          BL       RTC_WaitForLastTask
                  |L6.20|
;;;155        }
;;;156    }
000014  bd10              POP      {r4,pc}
;;;157    /*
                          ENDP


                          AREA ||i.UsageFault_Handler||, CODE, READONLY, ALIGN=1

                  UsageFault_Handler PROC
;;;122    */
;;;123    void UsageFault_Handler(void)
000000  bf00              NOP      
                  |L7.2|
;;;124    {
;;;125        /* 当用法异常时进入死循环 */
;;;126        while (1)
000002  e7fe              B        |L7.2|
;;;127        {
;;;128        }
;;;129    }
;;;130    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\stm32f10x_it.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_stm32f10x_it_c_bb8ca80c____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___14_stm32f10x_it_c_bb8ca80c____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_stm32f10x_it_c_bb8ca80c____REVSH|
#line 128
|__asm___14_stm32f10x_it_c_bb8ca80c____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
