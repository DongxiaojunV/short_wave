; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\short_wave\obj\w5500.o --asm_dir=.\short_wave\List\ --list_dir=.\short_wave\List\ --depend=.\short_wave\obj\w5500.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\adc -I..\..\User\rtc -I..\..\User\internal_flash -I..\..\User\iwdg -I..\..\Task -I..\..\User\can -I..\..\User\firmware_upgrade -I..\..\User\STMFLASH -I..\..\User\IAP -I.\RTE\_Short_Wave -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\short_wave\obj\w5500.crf ..\..\User\W5500.c]
                          THUMB

                          AREA ||i.Detect_Gateway||, CODE, READONLY, ALIGN=2

                  Detect_Gateway PROC
;;;709    *******************************************************************************/
;;;710    unsigned char Detect_Gateway(SOCKET s)
000000  b538              PUSH     {r3-r5,lr}
;;;711    {
000002  4605              MOV      r5,r0
;;;712    	unsigned char ip_adde[4];
;;;713    	ip_adde[0]=IP_Addr[0]+1;
000004  482f              LDR      r0,|L1.196|
000006  7800              LDRB     r0,[r0,#0]  ; IP_Addr
000008  1c40              ADDS     r0,r0,#1
00000a  b2c0              UXTB     r0,r0
00000c  f88d0000          STRB     r0,[sp,#0]
;;;714    	ip_adde[1]=IP_Addr[1]+1;
000010  482c              LDR      r0,|L1.196|
000012  7840              LDRB     r0,[r0,#1]  ; IP_Addr
000014  1c40              ADDS     r0,r0,#1
000016  b2c0              UXTB     r0,r0
000018  f88d0001          STRB     r0,[sp,#1]
;;;715    	ip_adde[2]=IP_Addr[2]+1;
00001c  4829              LDR      r0,|L1.196|
00001e  7880              LDRB     r0,[r0,#2]  ; IP_Addr
000020  1c40              ADDS     r0,r0,#1
000022  b2c0              UXTB     r0,r0
000024  f88d0002          STRB     r0,[sp,#2]
;;;716    	ip_adde[3]=IP_Addr[3]+1;
000028  4826              LDR      r0,|L1.196|
00002a  78c0              LDRB     r0,[r0,#3]  ; IP_Addr
00002c  1c40              ADDS     r0,r0,#1
00002e  b2c0              UXTB     r0,r0
000030  f88d0003          STRB     r0,[sp,#3]
;;;717    
;;;718    	//检查网关及获取网关的物理地址
;;;719    	Write_W5500_SOCK_4Byte(s,Sn_DIPR,ip_adde);//向目的地址寄存器写入与本机IP不同的IP值
000034  466a              MOV      r2,sp
000036  210c              MOVS     r1,#0xc
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       Write_W5500_SOCK_4Byte
;;;720    	Write_W5500_SOCK_1Byte(s,Sn_MR,MR_TCP);//设置socket为TCP协议模式
00003e  2201              MOVS     r2,#1
000040  2100              MOVS     r1,#0
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;721    	Write_W5500_SOCK_1Byte(s,Sn_CR,OPEN);//打开Socket	
000048  2201              MOVS     r2,#1
00004a  4611              MOV      r1,r2
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;722    	My_Delay_xms(5);//延时5ms 	
000052  2005              MOVS     r0,#5
000054  f7fffffe          BL       My_Delay_xms
;;;723    	
;;;724    	if(Read_W5500_SOCK_1Byte(s,Sn_SR) != SOCK_INIT)//如果socket打开失败
000058  2103              MOVS     r1,#3
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       Read_W5500_SOCK_1Byte
000060  2813              CMP      r0,#0x13
000062  d006              BEQ      |L1.114|
;;;725    	{
;;;726    		Write_W5500_SOCK_1Byte(s,Sn_CR,CLOSE);//打开不成功,关闭Socket
000064  2210              MOVS     r2,#0x10
000066  2101              MOVS     r1,#1
000068  4628              MOV      r0,r5
00006a  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;727    		return FALSE_W5500;//返回FALSE(0x00)
00006e  2000              MOVS     r0,#0
                  |L1.112|
;;;728    	}
;;;729    
;;;730    	Write_W5500_SOCK_1Byte(s,Sn_CR,CONNECT);//设置Socket为Connect模式						
;;;731    
;;;732    	do
;;;733    	{
;;;734    		u8 j=0;
;;;735    		j=Read_W5500_SOCK_1Byte(s,Sn_IR);//读取Socket0中断标志寄存器
;;;736    		if(j!=0)
;;;737    		Write_W5500_SOCK_1Byte(s,Sn_IR,j);
;;;738    		My_Delay_xms(5);//延时5ms 
;;;739    		if((j&IR_TIMEOUT) == IR_TIMEOUT)
;;;740    		{
;;;741    			return FALSE_W5500;	
;;;742    		}
;;;743    		else if(Read_W5500_SOCK_1Byte(s,Sn_DHAR) != 0xff)
;;;744    		{
;;;745    			Write_W5500_SOCK_1Byte(s,Sn_CR,CLOSE);//关闭Socket
;;;746    			return TRUE_W5500;							
;;;747    		}
;;;748    	}while(1);
;;;749    }
000070  bd38              POP      {r3-r5,pc}
                  |L1.114|
000072  2204              MOVS     r2,#4                 ;730
000074  2101              MOVS     r1,#1                 ;730
000076  4628              MOV      r0,r5                 ;730
000078  f7fffffe          BL       Write_W5500_SOCK_1Byte
00007c  bf00              NOP                            ;732
                  |L1.126|
00007e  2400              MOVS     r4,#0                 ;734
000080  2102              MOVS     r1,#2                 ;735
000082  4628              MOV      r0,r5                 ;735
000084  f7fffffe          BL       Read_W5500_SOCK_1Byte
000088  4604              MOV      r4,r0                 ;735
00008a  b124              CBZ      r4,|L1.150|
00008c  4622              MOV      r2,r4                 ;737
00008e  2102              MOVS     r1,#2                 ;737
000090  4628              MOV      r0,r5                 ;737
000092  f7fffffe          BL       Write_W5500_SOCK_1Byte
                  |L1.150|
000096  2005              MOVS     r0,#5                 ;738
000098  f7fffffe          BL       My_Delay_xms
00009c  f0040008          AND      r0,r4,#8              ;739
0000a0  2808              CMP      r0,#8                 ;739
0000a2  d101              BNE      |L1.168|
0000a4  2000              MOVS     r0,#0                 ;741
0000a6  e7e3              B        |L1.112|
                  |L1.168|
0000a8  2106              MOVS     r1,#6                 ;743
0000aa  4628              MOV      r0,r5                 ;743
0000ac  f7fffffe          BL       Read_W5500_SOCK_1Byte
0000b0  28ff              CMP      r0,#0xff              ;743
0000b2  d006              BEQ      |L1.194|
0000b4  2210              MOVS     r2,#0x10              ;745
0000b6  2101              MOVS     r1,#1                 ;745
0000b8  4628              MOV      r0,r5                 ;745
0000ba  f7fffffe          BL       Write_W5500_SOCK_1Byte
0000be  20ff              MOVS     r0,#0xff              ;746
0000c0  e7d6              B        |L1.112|
                  |L1.194|
0000c2  e7dc              B        |L1.126|
;;;750    
                          ENDP

                  |L1.196|
                          DCD      IP_Addr

                          AREA ||i.EXTI15_10_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI15_10_IRQHandler PROC
;;;131    *******************************************************************************/
;;;132    void EXTI15_10_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;133    {
;;;134    	if(EXTI_GetITStatus(EXTI_Line11) != RESET)
000002  f44f6000          MOV      r0,#0x800
000006  f7fffffe          BL       EXTI_GetITStatus
00000a  b130              CBZ      r0,|L2.26|
;;;135    	{
;;;136    		EXTI_ClearITPendingBit(EXTI_Line11);
00000c  f44f6000          MOV      r0,#0x800
000010  f7fffffe          BL       EXTI_ClearITPendingBit
;;;137    		W5500_Interrupt=1;	
000014  2001              MOVS     r0,#1
000016  4901              LDR      r1,|L2.28|
000018  7008              STRB     r0,[r1,#0]
                  |L2.26|
;;;138    	}
;;;139    }
00001a  bd10              POP      {r4,pc}
;;;140    
                          ENDP

                  |L2.28|
                          DCD      W5500_Interrupt

                          AREA ||i.Read_SOCK_Data_Buffer||, CODE, READONLY, ALIGN=2

                  Read_SOCK_Data_Buffer PROC
;;;420    *******************************************************************************/
;;;421    unsigned short Read_SOCK_Data_Buffer(SOCKET s, unsigned char *dat_ptr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;422    {
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
;;;423    	unsigned short rx_size;
;;;424    	unsigned short offset, offset1;
;;;425    	unsigned short i;
;;;426    	unsigned char j;
;;;427    
;;;428    	rx_size=Read_W5500_SOCK_2Byte(s,Sn_RX_RSR);
000008  2126              MOVS     r1,#0x26
00000a  4640              MOV      r0,r8
00000c  f7fffffe          BL       Read_W5500_SOCK_2Byte
000010  4606              MOV      r6,r0
;;;429    	if(rx_size==0) return 0;//没接收到数据则返回
000012  b916              CBNZ     r6,|L3.26|
000014  2000              MOVS     r0,#0
                  |L3.22|
;;;430    	if(rx_size>1460) rx_size=1460;
;;;431    
;;;432    	offset=Read_W5500_SOCK_2Byte(s,Sn_RX_RD);
;;;433    	offset1=offset;
;;;434    	offset&=(S_RX_SIZE-1);//计算实际的物理地址
;;;435    
;;;436    	GPIO_ResetBits(W5500_SCS_PORT, W5500_SCS);//置W5500的SCS为低电平
;;;437    
;;;438    	SPI2_Send_Short(offset);//写16位地址
;;;439    	SPI2_Send_Byte(VDM|RWB_READ|(s*0x20+0x18));//写控制字节,N个字节数据长度,读数据,选择端口s的寄存器
;;;440    	j=SPI_I2S_ReceiveData(SPI2);
;;;441    	
;;;442    	if((offset+rx_size)<S_RX_SIZE)//如果最大地址未超过W5500接收缓冲区寄存器的最大地址
;;;443    	{
;;;444    		for(i=0;i<rx_size;i++)//循环读取rx_size个字节数据
;;;445    		{
;;;446    			SPI2_Send_Byte(0x00);//发送一个哑数据
;;;447    			j=SPI_I2S_ReceiveData(SPI2);//读取1个字节数据
;;;448    			*dat_ptr=j;//将读取到的数据保存到数据保存缓冲区
;;;449    			dat_ptr++;//数据保存缓冲区指针地址自增1
;;;450    		}
;;;451    	}
;;;452    	else//如果最大地址超过W5500接收缓冲区寄存器的最大地址
;;;453    	{
;;;454    		offset=S_RX_SIZE-offset;
;;;455    		for(i=0;i<offset;i++)//循环读取出前offset个字节数据
;;;456    		{
;;;457    			SPI2_Send_Byte(0x00);//发送一个哑数据
;;;458    			j=SPI_I2S_ReceiveData(SPI2);//读取1个字节数据
;;;459    			*dat_ptr=j;//将读取到的数据保存到数据保存缓冲区
;;;460    			dat_ptr++;//数据保存缓冲区指针地址自增1
;;;461    		}
;;;462    		GPIO_SetBits(W5500_SCS_PORT, W5500_SCS); //置W5500的SCS为高电平
;;;463    
;;;464    		GPIO_ResetBits(W5500_SCS_PORT, W5500_SCS);//置W5500的SCS为低电平
;;;465    
;;;466    		SPI2_Send_Short(0x00);//写16位地址
;;;467    		SPI2_Send_Byte(VDM|RWB_READ|(s*0x20+0x18));//写控制字节,N个字节数据长度,读数据,选择端口s的寄存器
;;;468    		j=SPI_I2S_ReceiveData(SPI2);
;;;469    
;;;470    		for(;i<rx_size;i++)//循环读取后rx_size-offset个字节数据
;;;471    		{
;;;472    			SPI2_Send_Byte(0x00);//发送一个哑数据
;;;473    			j=SPI_I2S_ReceiveData(SPI2);//读取1个字节数据
;;;474    			*dat_ptr=j;//将读取到的数据保存到数据保存缓冲区
;;;475    			dat_ptr++;//数据保存缓冲区指针地址自增1
;;;476    		}
;;;477    	}
;;;478    	GPIO_SetBits(W5500_SCS_PORT, W5500_SCS); //置W5500的SCS为高电平
;;;479    
;;;480    	offset1+=rx_size;//更新实际物理地址,即下次读取接收到的数据的起始地址
;;;481    	Write_W5500_SOCK_2Byte(s, Sn_RX_RD, offset1);
;;;482    	Write_W5500_SOCK_1Byte(s, Sn_CR, RECV);//发送启动接收命令
;;;483    	return rx_size;//返回接收到数据的长度
;;;484    }
000016  e8bd87f0          POP      {r4-r10,pc}
                  |L3.26|
00001a  f24050b4          MOV      r0,#0x5b4             ;430
00001e  4286              CMP      r6,r0                 ;430
000020  dd00              BLE      |L3.36|
000022  4606              MOV      r6,r0                 ;430
                  |L3.36|
000024  2128              MOVS     r1,#0x28              ;432
000026  4640              MOV      r0,r8                 ;432
000028  f7fffffe          BL       Read_W5500_SOCK_2Byte
00002c  4607              MOV      r7,r0                 ;432
00002e  46b9              MOV      r9,r7                 ;433
000030  f3c7070a          UBFX     r7,r7,#0,#11          ;434
000034  f44f5180          MOV      r1,#0x1000            ;436
000038  483b              LDR      r0,|L3.296|
00003a  f7fffffe          BL       GPIO_ResetBits
00003e  4638              MOV      r0,r7                 ;438
000040  f7fffffe          BL       SPI2_Send_Short
000044  2118              MOVS     r1,#0x18              ;439
000046  eb011148          ADD      r1,r1,r8,LSL #5       ;439
00004a  b2c8              UXTB     r0,r1                 ;439
00004c  f7fffffe          BL       SPI2_Send_Byte
000050  4836              LDR      r0,|L3.300|
000052  f7fffffe          BL       SPI_I2S_ReceiveData
000056  f0000aff          AND      r10,r0,#0xff          ;440
00005a  19b8              ADDS     r0,r7,r6              ;442
00005c  f5b06f00          CMP      r0,#0x800             ;442
000060  da11              BGE      |L3.134|
000062  2400              MOVS     r4,#0                 ;444
000064  e00c              B        |L3.128|
                  |L3.102|
000066  2000              MOVS     r0,#0                 ;446
000068  f7fffffe          BL       SPI2_Send_Byte
00006c  482f              LDR      r0,|L3.300|
00006e  f7fffffe          BL       SPI_I2S_ReceiveData
000072  f0000aff          AND      r10,r0,#0xff          ;447
000076  f885a000          STRB     r10,[r5,#0]           ;448
00007a  1c6d              ADDS     r5,r5,#1              ;449
00007c  1c60              ADDS     r0,r4,#1              ;444
00007e  b284              UXTH     r4,r0                 ;444
                  |L3.128|
000080  42b4              CMP      r4,r6                 ;444
000082  dbf0              BLT      |L3.102|
000084  e03b              B        |L3.254|
                  |L3.134|
000086  f5c76000          RSB      r0,r7,#0x800          ;454
00008a  b287              UXTH     r7,r0                 ;454
00008c  2400              MOVS     r4,#0                 ;455
00008e  e00c              B        |L3.170|
                  |L3.144|
000090  2000              MOVS     r0,#0                 ;457
000092  f7fffffe          BL       SPI2_Send_Byte
000096  4825              LDR      r0,|L3.300|
000098  f7fffffe          BL       SPI_I2S_ReceiveData
00009c  f0000aff          AND      r10,r0,#0xff          ;458
0000a0  f885a000          STRB     r10,[r5,#0]           ;459
0000a4  1c6d              ADDS     r5,r5,#1              ;460
0000a6  1c60              ADDS     r0,r4,#1              ;455
0000a8  b284              UXTH     r4,r0                 ;455
                  |L3.170|
0000aa  42bc              CMP      r4,r7                 ;455
0000ac  dbf0              BLT      |L3.144|
0000ae  f44f5180          MOV      r1,#0x1000            ;462
0000b2  481d              LDR      r0,|L3.296|
0000b4  f7fffffe          BL       GPIO_SetBits
0000b8  f44f5180          MOV      r1,#0x1000            ;464
0000bc  481a              LDR      r0,|L3.296|
0000be  f7fffffe          BL       GPIO_ResetBits
0000c2  2000              MOVS     r0,#0                 ;466
0000c4  f7fffffe          BL       SPI2_Send_Short
0000c8  2118              MOVS     r1,#0x18              ;467
0000ca  eb011148          ADD      r1,r1,r8,LSL #5       ;467
0000ce  b2c8              UXTB     r0,r1                 ;467
0000d0  f7fffffe          BL       SPI2_Send_Byte
0000d4  4815              LDR      r0,|L3.300|
0000d6  f7fffffe          BL       SPI_I2S_ReceiveData
0000da  f0000aff          AND      r10,r0,#0xff          ;468
0000de  e00c              B        |L3.250|
                  |L3.224|
0000e0  2000              MOVS     r0,#0                 ;472
0000e2  f7fffffe          BL       SPI2_Send_Byte
0000e6  4811              LDR      r0,|L3.300|
0000e8  f7fffffe          BL       SPI_I2S_ReceiveData
0000ec  f0000aff          AND      r10,r0,#0xff          ;473
0000f0  f885a000          STRB     r10,[r5,#0]           ;474
0000f4  1c6d              ADDS     r5,r5,#1              ;475
0000f6  1c60              ADDS     r0,r4,#1              ;470
0000f8  b284              UXTH     r4,r0                 ;470
                  |L3.250|
0000fa  42b4              CMP      r4,r6                 ;470
0000fc  dbf0              BLT      |L3.224|
                  |L3.254|
0000fe  f44f5180          MOV      r1,#0x1000            ;478
000102  4809              LDR      r0,|L3.296|
000104  f7fffffe          BL       GPIO_SetBits
000108  eb090006          ADD      r0,r9,r6              ;480
00010c  fa1ff980          UXTH     r9,r0                 ;480
000110  464a              MOV      r2,r9                 ;481
000112  2128              MOVS     r1,#0x28              ;481
000114  4640              MOV      r0,r8                 ;481
000116  f7fffffe          BL       Write_W5500_SOCK_2Byte
00011a  2240              MOVS     r2,#0x40              ;482
00011c  2101              MOVS     r1,#1                 ;482
00011e  4640              MOV      r0,r8                 ;482
000120  f7fffffe          BL       Write_W5500_SOCK_1Byte
000124  4630              MOV      r0,r6                 ;483
000126  e776              B        |L3.22|
;;;485    
                          ENDP

                  |L3.296|
                          DCD      0x40010c00
                  |L3.300|
                          DCD      0x40003800

                          AREA ||i.Read_W5500_1Byte||, CODE, READONLY, ALIGN=2

                  Read_W5500_1Byte PROC
;;;342    *******************************************************************************/
;;;343    unsigned char Read_W5500_1Byte(unsigned short reg)
000000  b570              PUSH     {r4-r6,lr}
;;;344    {
000002  4604              MOV      r4,r0
;;;345    	unsigned char i;
;;;346    
;;;347    	GPIO_ResetBits(W5500_SCS_PORT, W5500_SCS);//置W5500的SCS为低电平
000004  f44f5180          MOV      r1,#0x1000
000008  480d              LDR      r0,|L4.64|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;348    			
;;;349    	SPI2_Send_Short(reg);//通过SPI2写16位寄存器地址
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       SPI2_Send_Short
;;;350    	SPI2_Send_Byte(FDM1|RWB_READ|COMMON_R);//通过SPI2写控制字节,1个字节数据长度,读数据,选择通用寄存器
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       SPI2_Send_Byte
;;;351    
;;;352    	i=SPI_I2S_ReceiveData(SPI2);
00001a  480a              LDR      r0,|L4.68|
00001c  f7fffffe          BL       SPI_I2S_ReceiveData
000020  b2c5              UXTB     r5,r0
;;;353    	SPI2_Send_Byte(0x00);//发送一个哑数据
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       SPI2_Send_Byte
;;;354    	i=SPI_I2S_ReceiveData(SPI2);//读取1个字节数据
000028  4806              LDR      r0,|L4.68|
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
00002e  b2c5              UXTB     r5,r0
;;;355    
;;;356    	GPIO_SetBits(W5500_SCS_PORT, W5500_SCS);//置W5500的SCS为高电平
000030  f44f5180          MOV      r1,#0x1000
000034  4802              LDR      r0,|L4.64|
000036  f7fffffe          BL       GPIO_SetBits
;;;357    	return i;//返回读取到的寄存器数据
00003a  4628              MOV      r0,r5
;;;358    }
00003c  bd70              POP      {r4-r6,pc}
;;;359    
                          ENDP

00003e  0000              DCW      0x0000
                  |L4.64|
                          DCD      0x40010c00
                  |L4.68|
                          DCD      0x40003800

                          AREA ||i.Read_W5500_SOCK_1Byte||, CODE, READONLY, ALIGN=2

                  Read_W5500_SOCK_1Byte PROC
;;;367    *******************************************************************************/
;;;368    unsigned char Read_W5500_SOCK_1Byte(SOCKET s, unsigned short reg)
000000  b570              PUSH     {r4-r6,lr}
;;;369    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;370    	unsigned char i;
;;;371    
;;;372    	GPIO_ResetBits(W5500_SCS_PORT, W5500_SCS);//置W5500的SCS为低电平
000006  f44f5180          MOV      r1,#0x1000
00000a  4810              LDR      r0,|L5.76|
00000c  f7fffffe          BL       GPIO_ResetBits
;;;373    			
;;;374    	SPI2_Send_Short(reg);//通过SPI2写16位寄存器地址
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       SPI2_Send_Short
;;;375    	SPI2_Send_Byte(FDM1|RWB_READ|(s*0x20+0x08));//通过SPI2写控制字节,1个字节数据长度,读数据,选择端口s的寄存器
000016  2108              MOVS     r1,#8
000018  eb011144          ADD      r1,r1,r4,LSL #5
00001c  b2c9              UXTB     r1,r1
00001e  f0410001          ORR      r0,r1,#1
000022  f7fffffe          BL       SPI2_Send_Byte
;;;376    
;;;377    	i=SPI_I2S_ReceiveData(SPI2);
000026  480a              LDR      r0,|L5.80|
000028  f7fffffe          BL       SPI_I2S_ReceiveData
00002c  b2c6              UXTB     r6,r0
;;;378    	SPI2_Send_Byte(0x00);//发送一个哑数据
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       SPI2_Send_Byte
;;;379    	i=SPI_I2S_ReceiveData(SPI2);//读取1个字节数据
000034  4806              LDR      r0,|L5.80|
000036  f7fffffe          BL       SPI_I2S_ReceiveData
00003a  b2c6              UXTB     r6,r0
;;;380    
;;;381    	GPIO_SetBits(W5500_SCS_PORT, W5500_SCS);//置W5500的SCS为高电平
00003c  f44f5180          MOV      r1,#0x1000
000040  4802              LDR      r0,|L5.76|
000042  f7fffffe          BL       GPIO_SetBits
;;;382    	return i;//返回读取到的寄存器数据
000046  4630              MOV      r0,r6
;;;383    }
000048  bd70              POP      {r4-r6,pc}
;;;384    
                          ENDP

00004a  0000              DCW      0x0000
                  |L5.76|
                          DCD      0x40010c00
                  |L5.80|
                          DCD      0x40003800

                          AREA ||i.Read_W5500_SOCK_2Byte||, CODE, READONLY, ALIGN=2

                  Read_W5500_SOCK_2Byte PROC
;;;392    *******************************************************************************/
;;;393    unsigned short Read_W5500_SOCK_2Byte(SOCKET s, unsigned short reg)
000000  b570              PUSH     {r4-r6,lr}
;;;394    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;395    	unsigned short i;
;;;396    
;;;397    	GPIO_ResetBits(W5500_SCS_PORT, W5500_SCS);//置W5500的SCS为低电平
000006  f44f5180          MOV      r1,#0x1000
00000a  4816              LDR      r0,|L6.100|
00000c  f7fffffe          BL       GPIO_ResetBits
;;;398    			
;;;399    	SPI2_Send_Short(reg);//通过SPI2写16位寄存器地址
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       SPI2_Send_Short
;;;400    	SPI2_Send_Byte(FDM2|RWB_READ|(s*0x20+0x08));//通过SPI2写控制字节,2个字节数据长度,读数据,选择端口s的寄存器
000016  2108              MOVS     r1,#8
000018  eb011145          ADD      r1,r1,r5,LSL #5
00001c  b2c9              UXTB     r1,r1
00001e  f0410002          ORR      r0,r1,#2
000022  f7fffffe          BL       SPI2_Send_Byte
;;;401    
;;;402    	i=SPI_I2S_ReceiveData(SPI2);
000026  4810              LDR      r0,|L6.104|
000028  f7fffffe          BL       SPI_I2S_ReceiveData
00002c  4604              MOV      r4,r0
;;;403    	SPI2_Send_Byte(0x00);//发送一个哑数据
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       SPI2_Send_Byte
;;;404    	i=SPI_I2S_ReceiveData(SPI2);//读取高位数据
000034  480c              LDR      r0,|L6.104|
000036  f7fffffe          BL       SPI_I2S_ReceiveData
00003a  4604              MOV      r4,r0
;;;405    	SPI2_Send_Byte(0x00);//发送一个哑数据
00003c  2000              MOVS     r0,#0
00003e  f7fffffe          BL       SPI2_Send_Byte
;;;406    	i*=256;
000042  f64f70ff          MOV      r0,#0xffff
000046  ea002404          AND      r4,r0,r4,LSL #8
;;;407    	i+=SPI_I2S_ReceiveData(SPI2);//读取低位数据
00004a  4807              LDR      r0,|L6.104|
00004c  f7fffffe          BL       SPI_I2S_ReceiveData
000050  4420              ADD      r0,r0,r4
000052  b284              UXTH     r4,r0
;;;408    
;;;409    	GPIO_SetBits(W5500_SCS_PORT, W5500_SCS);//置W5500的SCS为高电平
000054  f44f5180          MOV      r1,#0x1000
000058  4802              LDR      r0,|L6.100|
00005a  f7fffffe          BL       GPIO_SetBits
;;;410    	return i;//返回读取到的寄存器数据
00005e  4620              MOV      r0,r4
;;;411    }
000060  bd70              POP      {r4-r6,pc}
;;;412    
                          ENDP

000062  0000              DCW      0x0000
                  |L6.100|
                          DCD      0x40010c00
                  |L6.104|
                          DCD      0x40003800

                          AREA ||i.SPI2_Send_Byte||, CODE, READONLY, ALIGN=2

                  SPI2_Send_Byte PROC
;;;190    *******************************************************************************/
;;;191    void SPI2_Send_Byte(unsigned char dat)
000000  b510              PUSH     {r4,lr}
;;;192    {
000002  4604              MOV      r4,r0
;;;193    	SPI_I2S_SendData(SPI2,dat);//写1个字节数据
000004  4621              MOV      r1,r4
000006  4805              LDR      r0,|L7.28|
000008  f7fffffe          BL       SPI_I2S_SendData
;;;194    	while(SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET);//等待数据寄存器空
00000c  bf00              NOP      
                  |L7.14|
00000e  2102              MOVS     r1,#2
000010  4802              LDR      r0,|L7.28|
000012  f7fffffe          BL       SPI_I2S_GetFlagStatus
000016  2800              CMP      r0,#0
000018  d0f9              BEQ      |L7.14|
;;;195    }
00001a  bd10              POP      {r4,pc}
;;;196    
                          ENDP

                  |L7.28|
                          DCD      0x40003800

                          AREA ||i.SPI2_Send_Short||, CODE, READONLY, ALIGN=1

                  SPI2_Send_Short PROC
;;;204    *******************************************************************************/
;;;205    void SPI2_Send_Short(unsigned short dat)
000000  b570              PUSH     {r4-r6,lr}
;;;206    {
000002  4604              MOV      r4,r0
;;;207    	SPI2_Send_Byte(dat/256);//写数据高位
000004  4625              MOV      r5,r4
000006  17e1              ASRS     r1,r4,#31
000008  eb046111          ADD      r1,r4,r1,LSR #24
00000c  f3c12007          UBFX     r0,r1,#8,#8
000010  f7fffffe          BL       SPI2_Send_Byte
;;;208    	SPI2_Send_Byte(dat);	//写数据低位
000014  b2e0              UXTB     r0,r4
000016  f7fffffe          BL       SPI2_Send_Byte
;;;209    }
00001a  bd70              POP      {r4-r6,pc}
;;;210    
                          ENDP


                          AREA ||i.SPI_Configuration||, CODE, READONLY, ALIGN=2

                  SPI_Configuration PROC
;;;148    *******************************************************************************/
;;;149    void SPI_Configuration(void)
000000  b500              PUSH     {lr}
;;;150    {
000002  b087              SUB      sp,sp,#0x1c
;;;151    	GPIO_InitTypeDef 	GPIO_InitStructure;
;;;152    	SPI_InitTypeDef   	SPI_InitStructure;	   
;;;153    
;;;154    	/* 初始化SCK、MISO、MOSI引脚 */
;;;155    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
000004  f44f4060          MOV      r0,#0xe000
000008  f8ad0018          STRH     r0,[sp,#0x18]
;;;156    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000c  2003              MOVS     r0,#3
00000e  f88d001a          STRB     r0,[sp,#0x1a]
;;;157    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000012  2018              MOVS     r0,#0x18
000014  f88d001b          STRB     r0,[sp,#0x1b]
;;;158    	GPIO_Init(GPIOB, &GPIO_InitStructure);
000018  a906              ADD      r1,sp,#0x18
00001a  481f              LDR      r0,|L9.152|
00001c  f7fffffe          BL       GPIO_Init
;;;159    	GPIO_SetBits(GPIOB,GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15);
000020  f44f4160          MOV      r1,#0xe000
000024  481c              LDR      r0,|L9.152|
000026  f7fffffe          BL       GPIO_SetBits
;;;160    
;;;161    	/* 初始化CS引脚 */
;;;162    	GPIO_InitStructure.GPIO_Pin = W5500_SCS;
00002a  f44f5080          MOV      r0,#0x1000
00002e  f8ad0018          STRH     r0,[sp,#0x18]
;;;163    	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
000032  2003              MOVS     r0,#3
000034  f88d001a          STRB     r0,[sp,#0x1a]
;;;164    	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;
000038  2010              MOVS     r0,#0x10
00003a  f88d001b          STRB     r0,[sp,#0x1b]
;;;165    	GPIO_Init(W5500_SCS_PORT, &GPIO_InitStructure);
00003e  a906              ADD      r1,sp,#0x18
000040  4815              LDR      r0,|L9.152|
000042  f7fffffe          BL       GPIO_Init
;;;166    	GPIO_SetBits(W5500_SCS_PORT, W5500_SCS);
000046  f44f5180          MOV      r1,#0x1000
00004a  4813              LDR      r0,|L9.152|
00004c  f7fffffe          BL       GPIO_SetBits
;;;167    
;;;168    	/* 初始化配置STM32 SPI2 */
;;;169    	SPI_InitStructure.SPI_Direction=SPI_Direction_2Lines_FullDuplex;	//SPI设置为双线双向全双工
000050  2000              MOVS     r0,#0
000052  f8ad0004          STRH     r0,[sp,#4]
;;;170    	SPI_InitStructure.SPI_Mode=SPI_Mode_Master;							//设置为主SPI
000056  f44f7082          MOV      r0,#0x104
00005a  f8ad0006          STRH     r0,[sp,#6]
;;;171    	SPI_InitStructure.SPI_DataSize=SPI_DataSize_8b;						//SPI发送接收8位帧结构
00005e  2000              MOVS     r0,#0
000060  f8ad0008          STRH     r0,[sp,#8]
;;;172    	SPI_InitStructure.SPI_CPOL=SPI_CPOL_Low;							//时钟悬空低
000064  f8ad000a          STRH     r0,[sp,#0xa]
;;;173    	SPI_InitStructure.SPI_CPHA=SPI_CPHA_1Edge;							//数据捕获于第1个时钟沿
000068  f8ad000c          STRH     r0,[sp,#0xc]
;;;174    	SPI_InitStructure.SPI_NSS=SPI_NSS_Soft;								//NSS由外部管脚管理
00006c  f44f7000          MOV      r0,#0x200
000070  f8ad000e          STRH     r0,[sp,#0xe]
;;;175    	SPI_InitStructure.SPI_BaudRatePrescaler=SPI_BaudRatePrescaler_2;	//波特率预分频值为2
000074  2000              MOVS     r0,#0
000076  f8ad0010          STRH     r0,[sp,#0x10]
;;;176    	SPI_InitStructure.SPI_FirstBit=SPI_FirstBit_MSB;					//数据传输从MSB位开始
00007a  f8ad0012          STRH     r0,[sp,#0x12]
;;;177    	SPI_InitStructure.SPI_CRCPolynomial=7;								//CRC多项式为7
00007e  2007              MOVS     r0,#7
000080  f8ad0014          STRH     r0,[sp,#0x14]
;;;178    	SPI_Init(SPI2,&SPI_InitStructure);									//根据SPI_InitStruct中指定的参数初始化外设SPI2寄存器
000084  a901              ADD      r1,sp,#4
000086  4805              LDR      r0,|L9.156|
000088  f7fffffe          BL       SPI_Init
;;;179    
;;;180    	SPI_Cmd(SPI2,ENABLE);	//STM32使能SPI2
00008c  2101              MOVS     r1,#1
00008e  4803              LDR      r0,|L9.156|
000090  f7fffffe          BL       SPI_Cmd
;;;181    }
000094  b007              ADD      sp,sp,#0x1c
000096  bd00              POP      {pc}
;;;182    
                          ENDP

                  |L9.152|
                          DCD      0x40010c00
                  |L9.156|
                          DCD      0x40003800

                          AREA ||i.Socket_Connect||, CODE, READONLY, ALIGN=1

                  Socket_Connect PROC
;;;809    *******************************************************************************/
;;;810    unsigned char Socket_Connect(SOCKET s)
000000  b510              PUSH     {r4,lr}
;;;811    {
000002  4604              MOV      r4,r0
;;;812    	Write_W5500_SOCK_1Byte(s,Sn_MR,MR_TCP);//设置socket为TCP模式
000004  2201              MOVS     r2,#1
000006  2100              MOVS     r1,#0
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;813    	Write_W5500_SOCK_1Byte(s,Sn_CR,OPEN);//打开Socket
00000e  2201              MOVS     r2,#1
000010  4611              MOV      r1,r2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;814    	My_Delay_xms(5);//延时5ms
000018  2005              MOVS     r0,#5
00001a  f7fffffe          BL       My_Delay_xms
;;;815    	if(Read_W5500_SOCK_1Byte(s,Sn_SR)!=SOCK_INIT)//如果socket打开失败
00001e  2103              MOVS     r1,#3
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       Read_W5500_SOCK_1Byte
000026  2813              CMP      r0,#0x13
000028  d006              BEQ      |L10.56|
;;;816    	{
;;;817    		Write_W5500_SOCK_1Byte(s,Sn_CR,CLOSE);//打开不成功,关闭Socket
00002a  2210              MOVS     r2,#0x10
00002c  2101              MOVS     r1,#1
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;818    		return FALSE_W5500;//返回FALSE(0x00)
000034  2000              MOVS     r0,#0
                  |L10.54|
;;;819    	}
;;;820    	Write_W5500_SOCK_1Byte(s,Sn_CR,CONNECT);//设置Socket为Connect模式
;;;821    	return TRUE_W5500;//返回TRUE,设置成功
;;;822    }
000036  bd10              POP      {r4,pc}
                  |L10.56|
000038  2204              MOVS     r2,#4                 ;820
00003a  2101              MOVS     r1,#1                 ;820
00003c  4620              MOV      r0,r4                 ;820
00003e  f7fffffe          BL       Write_W5500_SOCK_1Byte
000042  20ff              MOVS     r0,#0xff              ;821
000044  e7f7              B        |L10.54|
;;;823    
                          ENDP


                          AREA ||i.Socket_Init||, CODE, READONLY, ALIGN=2

                  Socket_Init PROC
;;;758    *******************************************************************************/
;;;759    void Socket_Init(SOCKET s)
000000  b510              PUSH     {r4,lr}
;;;760    {
000002  4604              MOV      r4,r0
;;;761    	//设置分片长度，参考W5500数据手册，该值可以不修改	
;;;762    	Write_W5500_SOCK_2Byte(s, Sn_MSSR, 1460);//最大分片字节数=1460(0x5b4)
000004  f24052b4          MOV      r2,#0x5b4
000008  2112              MOVS     r1,#0x12
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       Write_W5500_SOCK_2Byte
;;;763    	//设置指定端口
;;;764    	switch(s)
000010  2c08              CMP      r4,#8
000012  d235              BCS      |L11.128|
000014  e8dff004          TBB      [pc,r4]
000018  040f1a25          DCB      0x04,0x0f,0x1a,0x25
00001c  30313233          DCB      0x30,0x31,0x32,0x33
;;;765    	{
;;;766    		case 0:
;;;767    			//设置端口0的端口号
;;;768    			Write_W5500_SOCK_2Byte(s, Sn_PORT, S0_Port[0]*256+S0_Port[1]);				
000020  4819              LDR      r0,|L11.136|
000022  7841              LDRB     r1,[r0,#1]  ; S0_Port
000024  7800              LDRB     r0,[r0,#0]  ; S0_Port
000026  eb012000          ADD      r0,r1,r0,LSL #8
00002a  b282              UXTH     r2,r0
00002c  2104              MOVS     r1,#4
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       Write_W5500_SOCK_2Byte
;;;769    			break;
000034  e025              B        |L11.130|
;;;770    
;;;771    		case 1:
;;;772    			Write_W5500_SOCK_2Byte(s, Sn_PORT, S1_Port[0]*256+S1_Port[1]);
000036  4815              LDR      r0,|L11.140|
000038  7841              LDRB     r1,[r0,#1]  ; S1_Port
00003a  7800              LDRB     r0,[r0,#0]  ; S1_Port
00003c  eb012000          ADD      r0,r1,r0,LSL #8
000040  b282              UXTH     r2,r0
000042  2104              MOVS     r1,#4
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       Write_W5500_SOCK_2Byte
;;;773    			break;
00004a  e01a              B        |L11.130|
;;;774    
;;;775    		case 2:
;;;776    			Write_W5500_SOCK_2Byte(s, Sn_PORT, S2_Port[0]*256+S2_Port[1]);
00004c  4810              LDR      r0,|L11.144|
00004e  7841              LDRB     r1,[r0,#1]  ; S2_Port
000050  7800              LDRB     r0,[r0,#0]  ; S2_Port
000052  eb012000          ADD      r0,r1,r0,LSL #8
000056  b282              UXTH     r2,r0
000058  2104              MOVS     r1,#4
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       Write_W5500_SOCK_2Byte
;;;777    			break;
000060  e00f              B        |L11.130|
;;;778    
;;;779    		case 3:
;;;780    			Write_W5500_SOCK_2Byte(s, Sn_PORT, S3_Port[0]*256+S3_Port[1]);
000062  480c              LDR      r0,|L11.148|
000064  7841              LDRB     r1,[r0,#1]  ; S3_Port
000066  7800              LDRB     r0,[r0,#0]  ; S3_Port
000068  eb012000          ADD      r0,r1,r0,LSL #8
00006c  b282              UXTH     r2,r0
00006e  2104              MOVS     r1,#4
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       Write_W5500_SOCK_2Byte
;;;781    			break;
000076  e004              B        |L11.130|
;;;782    
;;;783    		case 4:
;;;784    			break;
000078  e003              B        |L11.130|
;;;785    
;;;786    		case 5:
;;;787    			break;
00007a  e002              B        |L11.130|
;;;788    
;;;789    		case 6:
;;;790    			break;
00007c  e001              B        |L11.130|
;;;791    
;;;792    		case 7:
;;;793    			break;
00007e  e000              B        |L11.130|
                  |L11.128|
;;;794    
;;;795    		default:
;;;796    			break;
000080  bf00              NOP      
                  |L11.130|
000082  bf00              NOP                            ;769
;;;797    	}
;;;798    }
000084  bd10              POP      {r4,pc}
;;;799    
                          ENDP

000086  0000              DCW      0x0000
                  |L11.136|
                          DCD      S0_Port
                  |L11.140|
                          DCD      S1_Port
                  |L11.144|
                          DCD      S2_Port
                  |L11.148|
                          DCD      S3_Port

                          AREA ||i.Socket_Listen||, CODE, READONLY, ALIGN=1

                  Socket_Listen PROC
;;;832    *******************************************************************************/
;;;833    unsigned char Socket_Listen(SOCKET s)
000000  b510              PUSH     {r4,lr}
;;;834    {
000002  4604              MOV      r4,r0
;;;835    	Write_W5500_SOCK_1Byte(s,Sn_MR,MR_TCP);//设置socket为TCP模式 
000004  2201              MOVS     r2,#1
000006  2100              MOVS     r1,#0
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;836    	Write_W5500_SOCK_1Byte(s,Sn_CR,OPEN);//打开Socket	
00000e  2201              MOVS     r2,#1
000010  4611              MOV      r1,r2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;837    	My_Delay_xms(5);//延时5ms
000018  2005              MOVS     r0,#5
00001a  f7fffffe          BL       My_Delay_xms
;;;838    	if(Read_W5500_SOCK_1Byte(s,Sn_SR)!=SOCK_INIT)//如果socket打开失败
00001e  2103              MOVS     r1,#3
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       Read_W5500_SOCK_1Byte
000026  2813              CMP      r0,#0x13
000028  d006              BEQ      |L12.56|
;;;839    	{
;;;840    		Write_W5500_SOCK_1Byte(s,Sn_CR,CLOSE);//打开不成功,关闭Socket
00002a  2210              MOVS     r2,#0x10
00002c  2101              MOVS     r1,#1
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;841    		return FALSE_W5500;//返回FALSE(0x00)
000034  2000              MOVS     r0,#0
                  |L12.54|
;;;842    	}	
;;;843    	Write_W5500_SOCK_1Byte(s,Sn_CR,LISTEN);//设置Socket为侦听模式	
;;;844    	My_Delay_xms(5);//延时5ms
;;;845    	if(Read_W5500_SOCK_1Byte(s,Sn_SR)!=SOCK_LISTEN)//如果socket设置失败
;;;846    	{
;;;847    		Write_W5500_SOCK_1Byte(s,Sn_CR,CLOSE);//设置不成功,关闭Socket
;;;848    		return FALSE_W5500;//返回FALSE(0x00)
;;;849    	}
;;;850    
;;;851    	return TRUE_W5500;
;;;852    
;;;853    	//至此完成了Socket的打开和设置侦听工作,至于远程客户端是否与它建立连接,则需要等待Socket中断，
;;;854    	//以判断Socket的连接是否成功。参考W5500数据手册的Socket中断状态
;;;855    	//在服务器侦听模式不需要设置目的IP和目的端口号
;;;856    }
000036  bd10              POP      {r4,pc}
                  |L12.56|
000038  2202              MOVS     r2,#2                 ;843
00003a  2101              MOVS     r1,#1                 ;843
00003c  4620              MOV      r0,r4                 ;843
00003e  f7fffffe          BL       Write_W5500_SOCK_1Byte
000042  2005              MOVS     r0,#5                 ;844
000044  f7fffffe          BL       My_Delay_xms
000048  2103              MOVS     r1,#3                 ;845
00004a  4620              MOV      r0,r4                 ;845
00004c  f7fffffe          BL       Read_W5500_SOCK_1Byte
000050  2814              CMP      r0,#0x14              ;845
000052  d006              BEQ      |L12.98|
000054  2210              MOVS     r2,#0x10              ;847
000056  2101              MOVS     r1,#1                 ;847
000058  4620              MOV      r0,r4                 ;847
00005a  f7fffffe          BL       Write_W5500_SOCK_1Byte
00005e  2000              MOVS     r0,#0                 ;848
000060  e7e9              B        |L12.54|
                  |L12.98|
000062  20ff              MOVS     r0,#0xff              ;851
000064  e7e7              B        |L12.54|
;;;857    
                          ENDP


                          AREA ||i.Socket_UDP||, CODE, READONLY, ALIGN=1

                  Socket_UDP PROC
;;;866    *******************************************************************************/
;;;867    unsigned char Socket_UDP(SOCKET s)
000000  b510              PUSH     {r4,lr}
;;;868    {
000002  4604              MOV      r4,r0
;;;869    	Write_W5500_SOCK_1Byte(s,Sn_MR,MR_UDP);//设置Socket为UDP模式*/
000004  2202              MOVS     r2,#2
000006  2100              MOVS     r1,#0
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;870    	Write_W5500_SOCK_1Byte(s,Sn_CR,OPEN);//打开Socket*/
00000e  2201              MOVS     r2,#1
000010  4611              MOV      r1,r2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;871    	My_Delay_xms(5);//延时5ms
000018  2005              MOVS     r0,#5
00001a  f7fffffe          BL       My_Delay_xms
;;;872    	if(Read_W5500_SOCK_1Byte(s,Sn_SR)!=SOCK_UDP)//如果Socket打开失败
00001e  2103              MOVS     r1,#3
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       Read_W5500_SOCK_1Byte
000026  2822              CMP      r0,#0x22
000028  d006              BEQ      |L13.56|
;;;873    	{
;;;874    		Write_W5500_SOCK_1Byte(s,Sn_CR,CLOSE);//打开不成功,关闭Socket
00002a  2210              MOVS     r2,#0x10
00002c  2101              MOVS     r1,#1
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;875    		return FALSE_W5500;//返回FALSE(0x00)
000034  2000              MOVS     r0,#0
                  |L13.54|
;;;876    	}
;;;877    	else
;;;878    		return TRUE_W5500;
;;;879    
;;;880    	//至此完成了Socket的打开和UDP模式设置,在这种模式下它不需要与远程主机建立连接
;;;881    	//因为Socket不需要建立连接,所以在发送数据前都可以设置目的主机IP和目的Socket的端口号
;;;882    	//如果目的主机IP和目的Socket的端口号是固定的,在运行过程中没有改变,那么也可以在这里设置
;;;883    }
000036  bd10              POP      {r4,pc}
                  |L13.56|
000038  20ff              MOVS     r0,#0xff              ;878
00003a  e7fc              B        |L13.54|
;;;884    
                          ENDP


                          AREA ||i.Socketn_Char_Send||, CODE, READONLY, ALIGN=2

                  Socketn_Char_Send PROC
;;;563    *******************************************************************************/
;;;564    void Socketn_Char_Send(SOCKET s,char *dat_ptr, uint8_t size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;565    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
;;;566    	unsigned short offset,offset1;
;;;567    	unsigned short i;
;;;568    
;;;569    	//如果是UDP模式,可以在此设置目的主机的IP和端口号
;;;570    	if((Read_W5500_SOCK_1Byte(s,Sn_MR)&0x0f) != SOCK_UDP)//如果Socket打开失败
00000a  2100              MOVS     r1,#0
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       Read_W5500_SOCK_1Byte
000012  f000000f          AND      r0,r0,#0xf
000016  2822              CMP      r0,#0x22
000018  d020              BEQ      |L14.92|
;;;571    	{		
;;;572    			if(s==3)
00001a  2e03              CMP      r6,#3
00001c  d10f              BNE      |L14.62|
;;;573    			{
;;;574    				Write_W5500_SOCK_4Byte(s, Sn_DIPR, NTP_DIPR);//设置目的主机IP  		
00001e  4a43              LDR      r2,|L14.300|
000020  210c              MOVS     r1,#0xc
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       Write_W5500_SOCK_4Byte
;;;575    				Write_W5500_SOCK_2Byte(s, Sn_DPORTR, NTP_DPORT[0]*256+NTP_DPORT[1]);//设置目的主机端口号	
000028  4841              LDR      r0,|L14.304|
00002a  7841              LDRB     r1,[r0,#1]  ; NTP_DPORT
00002c  7800              LDRB     r0,[r0,#0]  ; NTP_DPORT
00002e  eb012000          ADD      r0,r1,r0,LSL #8
000032  b282              UXTH     r2,r0
000034  2110              MOVS     r1,#0x10
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       Write_W5500_SOCK_2Byte
00003c  e00e              B        |L14.92|
                  |L14.62|
;;;576    			}
;;;577    			else
;;;578    			{
;;;579    				Write_W5500_SOCK_4Byte(s, Sn_DIPR, UDP_DIPR);//设置目的主机IP  		
00003e  4a3d              LDR      r2,|L14.308|
000040  210c              MOVS     r1,#0xc
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       Write_W5500_SOCK_4Byte
;;;580    				Write_W5500_SOCK_2Byte(s, Sn_DPORTR, UDP_DPORT[0]*256+UDP_DPORT[1]);//设置目的主机端口号	
000048  483b              LDR      r0,|L14.312|
00004a  7841              LDRB     r1,[r0,#1]  ; UDP_DPORT
00004c  7800              LDRB     r0,[r0,#0]  ; UDP_DPORT
00004e  eb012000          ADD      r0,r1,r0,LSL #8
000052  b282              UXTH     r2,r0
000054  2110              MOVS     r1,#0x10
000056  4630              MOV      r0,r6
000058  f7fffffe          BL       Write_W5500_SOCK_2Byte
                  |L14.92|
;;;581    			}				
;;;582    	}
;;;583    
;;;584    	offset=Read_W5500_SOCK_2Byte(s,Sn_TX_WR);
00005c  2124              MOVS     r1,#0x24
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       Read_W5500_SOCK_2Byte
000064  4607              MOV      r7,r0
;;;585    	offset1=offset;
000066  46b9              MOV      r9,r7
;;;586    	offset&=(S_TX_SIZE-1);//计算实际的物理地址
000068  f3c7070a          UBFX     r7,r7,#0,#11
;;;587    
;;;588    	GPIO_ResetBits(W5500_SCS_PORT, W5500_SCS);//置W5500的SCS为低电平
00006c  f44f5180          MOV      r1,#0x1000
000070  4832              LDR      r0,|L14.316|
000072  f7fffffe          BL       GPIO_ResetBits
;;;589    
;;;590    	SPI2_Send_Short(offset);//写16位地址
000076  4638              MOV      r0,r7
000078  f7fffffe          BL       SPI2_Send_Short
;;;591    	SPI2_Send_Byte(VDM|RWB_WRITE|(s*0x20+0x10));//写控制字节,N个字节数据长度,写数据,选择端口s的寄存器
00007c  2110              MOVS     r1,#0x10
00007e  eb011146          ADD      r1,r1,r6,LSL #5
000082  b2c9              UXTB     r1,r1
000084  f0410004          ORR      r0,r1,#4
000088  f7fffffe          BL       SPI2_Send_Byte
;;;592    
;;;593    	if((offset+size)<S_TX_SIZE)//如果最大地址未超过W5500发送缓冲区寄存器的最大地址
00008c  eb070008          ADD      r0,r7,r8
000090  f5b06f00          CMP      r0,#0x800
000094  da0a              BGE      |L14.172|
;;;594    	{
;;;595    		for(i=0;i<size;i++)//循环写入size个字节数据
000096  2400              MOVS     r4,#0
000098  e005              B        |L14.166|
                  |L14.154|
;;;596    		{
;;;597    			SPI2_Send_Byte(*dat_ptr++);//写入一个字节的数据		
00009a  f8150b01          LDRB     r0,[r5],#1
00009e  f7fffffe          BL       SPI2_Send_Byte
0000a2  1c60              ADDS     r0,r4,#1              ;595
0000a4  b284              UXTH     r4,r0                 ;595
                  |L14.166|
0000a6  4544              CMP      r4,r8                 ;595
0000a8  dbf7              BLT      |L14.154|
0000aa  e02a              B        |L14.258|
                  |L14.172|
;;;598    		}
;;;599    	}
;;;600    	else//如果最大地址超过W5500发送缓冲区寄存器的最大地址
;;;601    	{
;;;602    		offset=S_TX_SIZE-offset;
0000ac  f5c76000          RSB      r0,r7,#0x800
0000b0  b287              UXTH     r7,r0
;;;603    		for(i=0;i<offset;i++)//循环写入前offset个字节数据
0000b2  2400              MOVS     r4,#0
0000b4  e005              B        |L14.194|
                  |L14.182|
;;;604    		{
;;;605    			SPI2_Send_Byte(*dat_ptr++);//写入一个字节的数据
0000b6  f8150b01          LDRB     r0,[r5],#1
0000ba  f7fffffe          BL       SPI2_Send_Byte
0000be  1c60              ADDS     r0,r4,#1              ;603
0000c0  b284              UXTH     r4,r0                 ;603
                  |L14.194|
0000c2  42bc              CMP      r4,r7                 ;603
0000c4  dbf7              BLT      |L14.182|
;;;606    		}
;;;607    		GPIO_SetBits(W5500_SCS_PORT, W5500_SCS); //置W5500的SCS为高电平
0000c6  f44f5180          MOV      r1,#0x1000
0000ca  481c              LDR      r0,|L14.316|
0000cc  f7fffffe          BL       GPIO_SetBits
;;;608    
;;;609    		GPIO_ResetBits(W5500_SCS_PORT, W5500_SCS);//置W5500的SCS为低电平
0000d0  f44f5180          MOV      r1,#0x1000
0000d4  4819              LDR      r0,|L14.316|
0000d6  f7fffffe          BL       GPIO_ResetBits
;;;610    
;;;611    		SPI2_Send_Short(0x00);//写16位地址
0000da  2000              MOVS     r0,#0
0000dc  f7fffffe          BL       SPI2_Send_Short
;;;612    		SPI2_Send_Byte(VDM|RWB_WRITE|(s*0x20+0x10));//写控制字节,N个字节数据长度,写数据,选择端口s的寄存器
0000e0  2110              MOVS     r1,#0x10
0000e2  eb011146          ADD      r1,r1,r6,LSL #5
0000e6  b2c9              UXTB     r1,r1
0000e8  f0410004          ORR      r0,r1,#4
0000ec  f7fffffe          BL       SPI2_Send_Byte
;;;613    
;;;614    		for(;i<size;i++)//循环写入size-offset个字节数据
0000f0  e005              B        |L14.254|
                  |L14.242|
;;;615    		{
;;;616    			SPI2_Send_Byte(*dat_ptr++);//写入一个字节的数据
0000f2  f8150b01          LDRB     r0,[r5],#1
0000f6  f7fffffe          BL       SPI2_Send_Byte
0000fa  1c60              ADDS     r0,r4,#1              ;614
0000fc  b284              UXTH     r4,r0                 ;614
                  |L14.254|
0000fe  4544              CMP      r4,r8                 ;614
000100  dbf7              BLT      |L14.242|
                  |L14.258|
;;;617    		}
;;;618    	}
;;;619    	GPIO_SetBits(W5500_SCS_PORT, W5500_SCS); //置W5500的SCS为高电平
000102  f44f5180          MOV      r1,#0x1000
000106  480d              LDR      r0,|L14.316|
000108  f7fffffe          BL       GPIO_SetBits
;;;620    
;;;621    	offset1+=size;//更新实际物理地址,即下次写待发送数据到发送数据缓冲区的起始地址
00010c  eb090008          ADD      r0,r9,r8
000110  fa1ff980          UXTH     r9,r0
;;;622    	Write_W5500_SOCK_2Byte(s, Sn_TX_WR, offset1);
000114  464a              MOV      r2,r9
000116  2124              MOVS     r1,#0x24
000118  4630              MOV      r0,r6
00011a  f7fffffe          BL       Write_W5500_SOCK_2Byte
;;;623    	Write_W5500_SOCK_1Byte(s, Sn_CR, SEND);//发送启动发送命令				
00011e  2220              MOVS     r2,#0x20
000120  2101              MOVS     r1,#1
000122  4630              MOV      r0,r6
000124  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;624    }
000128  e8bd87f0          POP      {r4-r10,pc}
;;;625    
                          ENDP

                  |L14.300|
                          DCD      NTP_DIPR
                  |L14.304|
                          DCD      NTP_DPORT
                  |L14.308|
                          DCD      UDP_DIPR
                  |L14.312|
                          DCD      UDP_DPORT
                  |L14.316|
                          DCD      0x40010c00

                          AREA ||i.W5500_GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  W5500_GPIO_Configuration PROC
;;;74     *******************************************************************************/
;;;75     void W5500_GPIO_Configuration(void)
000000  b50e              PUSH     {r1-r3,lr}
;;;76     {
;;;77     	GPIO_InitTypeDef  GPIO_InitStructure;
;;;78     	EXTI_InitTypeDef  EXTI_InitStructure;	
;;;79     
;;;80     	/* W5500_RST引脚初始化配置(PB10) */
;;;81     	GPIO_InitStructure.GPIO_Pin  = W5500_RST;
000002  f44f6080          MOV      r0,#0x400
000006  f8ad0008          STRH     r0,[sp,#8]
;;;82     	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_10MHz;
00000a  2001              MOVS     r0,#1
00000c  f88d000a          STRB     r0,[sp,#0xa]
;;;83     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000010  2010              MOVS     r0,#0x10
000012  f88d000b          STRB     r0,[sp,#0xb]
;;;84     	GPIO_Init(W5500_RST_PORT, &GPIO_InitStructure);
000016  a902              ADD      r1,sp,#8
000018  4814              LDR      r0,|L15.108|
00001a  f7fffffe          BL       GPIO_Init
;;;85     	GPIO_ResetBits(W5500_RST_PORT, W5500_RST);
00001e  f44f6180          MOV      r1,#0x400
000022  4812              LDR      r0,|L15.108|
000024  f7fffffe          BL       GPIO_ResetBits
;;;86     	
;;;87     	/* W5500_INT引脚初始化配置(PB11) */	
;;;88     	GPIO_InitStructure.GPIO_Pin = W5500_INT;
000028  f44f6000          MOV      r0,#0x800
00002c  f8ad0008          STRH     r0,[sp,#8]
;;;89     	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
000030  2003              MOVS     r0,#3
000032  f88d000a          STRB     r0,[sp,#0xa]
;;;90     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
000036  2048              MOVS     r0,#0x48
000038  f88d000b          STRB     r0,[sp,#0xb]
;;;91     	GPIO_Init(W5500_INT_PORT, &GPIO_InitStructure);
00003c  a902              ADD      r1,sp,#8
00003e  480b              LDR      r0,|L15.108|
000040  f7fffffe          BL       GPIO_Init
;;;92     		
;;;93     	/* Connect EXTI Line11 to PB11 */
;;;94     	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource11);
000044  210b              MOVS     r1,#0xb
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       GPIO_EXTILineConfig
;;;95     
;;;96     	/* PC4 as W5500 interrupt input */
;;;97     	EXTI_InitStructure.EXTI_Line = EXTI_Line11;
00004c  f44f6000          MOV      r0,#0x800
000050  9000              STR      r0,[sp,#0]
;;;98     	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
000052  2000              MOVS     r0,#0
000054  f88d0004          STRB     r0,[sp,#4]
;;;99     	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
000058  200c              MOVS     r0,#0xc
00005a  f88d0005          STRB     r0,[sp,#5]
;;;100    	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
00005e  2001              MOVS     r0,#1
000060  f88d0006          STRB     r0,[sp,#6]
;;;101    	EXTI_Init(&EXTI_InitStructure);
000064  4668              MOV      r0,sp
000066  f7fffffe          BL       EXTI_Init
;;;102    }
00006a  bd0e              POP      {r1-r3,pc}
;;;103    
                          ENDP

                  |L15.108|
                          DCD      0x40010c00

                          AREA ||i.W5500_Hardware_Reset||, CODE, READONLY, ALIGN=2

                  W5500_Hardware_Reset PROC
;;;633    *******************************************************************************/
;;;634    void W5500_Hardware_Reset(void)
000000  b510              PUSH     {r4,lr}
;;;635    {
;;;636    	GPIO_ResetBits(W5500_RST_PORT, W5500_RST);//复位引脚拉低
000002  f44f6180          MOV      r1,#0x400
000006  4807              LDR      r0,|L16.36|
000008  f7fffffe          BL       GPIO_ResetBits
;;;637    	My_Delay_xms(50);
00000c  2032              MOVS     r0,#0x32
00000e  f7fffffe          BL       My_Delay_xms
;;;638    	GPIO_SetBits(W5500_RST_PORT, W5500_RST);//复位引脚拉高
000012  f44f6180          MOV      r1,#0x400
000016  4803              LDR      r0,|L16.36|
000018  f7fffffe          BL       GPIO_SetBits
;;;639    	My_Delay_xms(200);
00001c  20c8              MOVS     r0,#0xc8
00001e  f7fffffe          BL       My_Delay_xms
;;;640    //	while((Read_W5500_1Byte(PHYCFGR)&LINK)==0);//等待以太网连接完成
;;;641    }
000022  bd10              POP      {r4,pc}
;;;642    
                          ENDP

                  |L16.36|
                          DCD      0x40010c00

                          AREA ||i.W5500_Init||, CODE, READONLY, ALIGN=2

                  W5500_Init PROC
;;;650    *******************************************************************************/
;;;651    void W5500_Init(void)
000000  b510              PUSH     {r4,lr}
;;;652    {
;;;653    	u8 i=0;
000002  2400              MOVS     r4,#0
;;;654    
;;;655    	Write_W5500_1Byte(MR, RST);//软件复位W5500,置1有效,复位后自动清0
000004  2180              MOVS     r1,#0x80
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       Write_W5500_1Byte
;;;656    	My_Delay_xms(10);//延时10ms,自己定义该函数
00000c  200a              MOVS     r0,#0xa
00000e  f7fffffe          BL       My_Delay_xms
;;;657    
;;;658    	//设置网关(Gateway)的IP地址,Gateway_IP为4字节unsigned char数组,自己定义 
;;;659    	//使用网关可以使通信突破子网的局限，通过网关可以访问到其它子网或进入Internet
;;;660    	Write_W5500_nByte(GAR, Gateway_IP, 4);
000012  2204              MOVS     r2,#4
000014  4926              LDR      r1,|L17.176|
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       Write_W5500_nByte
;;;661    			
;;;662    	//设置子网掩码(MASK)值,SUB_MASK为4字节unsigned char数组,自己定义
;;;663    	//子网掩码用于子网运算
;;;664    	Write_W5500_nByte(SUBR,Sub_Mask,4);		
00001c  2204              MOVS     r2,#4
00001e  4925              LDR      r1,|L17.180|
000020  2005              MOVS     r0,#5
000022  f7fffffe          BL       Write_W5500_nByte
;;;665    	
;;;666    	//设置物理地址,PHY_ADDR为6字节unsigned char数组,自己定义,用于唯一标识网络设备的物理地址值
;;;667    	//该地址值需要到IEEE申请，按照OUI的规定，前3个字节为厂商代码，后三个字节为产品序号
;;;668    	//如果自己定义物理地址，注意第一个字节必须为偶数
;;;669    	Write_W5500_nByte(SHAR,Phy_Addr,6);		
000026  2206              MOVS     r2,#6
000028  4923              LDR      r1,|L17.184|
00002a  2009              MOVS     r0,#9
00002c  f7fffffe          BL       Write_W5500_nByte
;;;670    
;;;671    	//设置本机的IP地址,IP_ADDR为4字节unsigned char数组,自己定义
;;;672    	//注意，网关IP必须与本机IP属于同一个子网，否则本机将无法找到网关
;;;673    	Write_W5500_nByte(SIPR,IP_Addr,4);		
000030  2204              MOVS     r2,#4
000032  4922              LDR      r1,|L17.188|
000034  200f              MOVS     r0,#0xf
000036  f7fffffe          BL       Write_W5500_nByte
;;;674    	
;;;675    	//设置发送缓冲区和接收缓冲区的大小，参考W5500数据手册
;;;676    	for(i=0;i<8;i++)
00003a  bf00              NOP      
00003c  e00b              B        |L17.86|
                  |L17.62|
;;;677    	{
;;;678    		Write_W5500_SOCK_1Byte(i,Sn_RXBUF_SIZE, 0x02);//Socket Rx memory size=2k
00003e  2202              MOVS     r2,#2
000040  211e              MOVS     r1,#0x1e
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;679    		Write_W5500_SOCK_1Byte(i,Sn_TXBUF_SIZE, 0x02);//Socket Tx mempry size=2k
000048  2202              MOVS     r2,#2
00004a  211f              MOVS     r1,#0x1f
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       Write_W5500_SOCK_1Byte
000052  1c60              ADDS     r0,r4,#1              ;676
000054  b2c4              UXTB     r4,r0                 ;676
                  |L17.86|
000056  2c08              CMP      r4,#8                 ;676
000058  dbf1              BLT      |L17.62|
;;;680    	}
;;;681    
;;;682    	//设置重试时间，默认为2000(200ms) 
;;;683    	//每一单位数值为100微秒,初始化时值设为2000(0x07D0),等于200毫秒
;;;684    	Write_W5500_2Byte(RTR, 0x07d0);
00005a  f44f61fa          MOV      r1,#0x7d0
00005e  2019              MOVS     r0,#0x19
000060  f7fffffe          BL       Write_W5500_2Byte
;;;685    
;;;686    	//设置重试次数，默认为8次 
;;;687    	//如果重发的次数超过设定值,则产生超时中断(相关的端口中断寄存器中的Sn_IR 超时位(TIMEOUT)置“1”)
;;;688    	Write_W5500_1Byte(RCR,8);
000064  2108              MOVS     r1,#8
000066  201b              MOVS     r0,#0x1b
000068  f7fffffe          BL       Write_W5500_1Byte
;;;689    
;;;690    	//启动中断，参考W5500数据手册确定自己需要的中断类型
;;;691    	//IMR_CONFLICT是IP地址冲突异常中断,IMR_UNREACH是UDP通信时，地址无法到达的异常中断
;;;692    	//其它是Socket事件中断，根据需要添加
;;;693      Write_W5500_1Byte(IMR,IM_IR7 | IM_IR6);	//打开IP冲突中断和目的地址不能到达中断
00006c  21c0              MOVS     r1,#0xc0
00006e  2016              MOVS     r0,#0x16
000070  f7fffffe          BL       Write_W5500_1Byte
;;;694    	Write_W5500_1Byte(SIMR,S0_IMR|S1_IMR|S2_IMR|S3_IMR);
000074  210f              MOVS     r1,#0xf
000076  2018              MOVS     r0,#0x18
000078  f7fffffe          BL       Write_W5500_1Byte
;;;695    	Write_W5500_SOCK_1Byte(0, Sn_IMR, IMR_SENDOK | IMR_TIMEOUT | IMR_RECV | IMR_DISCON | IMR_CON);
00007c  221f              MOVS     r2,#0x1f
00007e  212c              MOVS     r1,#0x2c
000080  2000              MOVS     r0,#0
000082  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;696    	Write_W5500_SOCK_1Byte(1, Sn_IMR, IMR_SENDOK | IMR_TIMEOUT | IMR_RECV | IMR_DISCON | IMR_CON);
000086  221f              MOVS     r2,#0x1f
000088  212c              MOVS     r1,#0x2c
00008a  2001              MOVS     r0,#1
00008c  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;697    	Write_W5500_SOCK_1Byte(2, Sn_IMR, IMR_SENDOK | IMR_TIMEOUT | IMR_RECV | IMR_DISCON | IMR_CON);
000090  221f              MOVS     r2,#0x1f
000092  212c              MOVS     r1,#0x2c
000094  2002              MOVS     r0,#2
000096  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;698    	Write_W5500_SOCK_1Byte(3, Sn_IMR, IMR_SENDOK | IMR_TIMEOUT | IMR_RECV | IMR_DISCON | IMR_CON);
00009a  221f              MOVS     r2,#0x1f
00009c  212c              MOVS     r1,#0x2c
00009e  2003              MOVS     r0,#3
0000a0  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;699    	Write_W5500_SOCK_1Byte(0,Sn_KPALVTR,0x01);
0000a4  2201              MOVS     r2,#1
0000a6  212f              MOVS     r1,#0x2f
0000a8  2000              MOVS     r0,#0
0000aa  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;700    }
0000ae  bd10              POP      {r4,pc}
;;;701    
                          ENDP

                  |L17.176|
                          DCD      Gateway_IP
                  |L17.180|
                          DCD      Sub_Mask
                  |L17.184|
                          DCD      Phy_Addr
                  |L17.188|
                          DCD      IP_Addr

                          AREA ||i.W5500_NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  W5500_NVIC_Configuration PROC
;;;111    *******************************************************************************/
;;;112    void W5500_NVIC_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;113    {
;;;114      	NVIC_InitTypeDef NVIC_InitStructure;
;;;115    
;;;116    	/* Enable the EXTI11 Interrupt */
;;;117    	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
000002  2028              MOVS     r0,#0x28
000004  f88d0000          STRB     r0,[sp,#0]
;;;118    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000008  2000              MOVS     r0,#0
00000a  f88d0001          STRB     r0,[sp,#1]
;;;119    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
00000e  2001              MOVS     r0,#1
000010  f88d0002          STRB     r0,[sp,#2]
;;;120    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000014  f88d0003          STRB     r0,[sp,#3]
;;;121    	NVIC_Init(&NVIC_InitStructure);
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       NVIC_Init
;;;122    }
00001e  bd08              POP      {r3,pc}
;;;123    
                          ENDP


                          AREA ||i.W5500_Process||, CODE, READONLY, ALIGN=2

                  W5500_Process PROC
;;;892    *******************************************************************************/
;;;893    void W5500_Process(void)
000000  b570              PUSH     {r4-r6,lr}
;;;894    {
;;;895    	unsigned char i,j;
;;;896    IntDispose:
000002  bf00              NOP      
                  |L19.4|
;;;897    	W5500_Interrupt=0;//清零中断标志
000004  2000              MOVS     r0,#0
000006  498e              LDR      r1,|L19.576|
000008  7008              STRB     r0,[r1,#0]
;;;898    	i = Read_W5500_1Byte(IR);//读取中断标志寄存器
00000a  2015              MOVS     r0,#0x15
00000c  f7fffffe          BL       Read_W5500_1Byte
000010  4605              MOV      r5,r0
;;;899    	Write_W5500_1Byte(IR, (i&0xf0));//回写清除中断标志
000012  f00501f0          AND      r1,r5,#0xf0
000016  2015              MOVS     r0,#0x15
000018  f7fffffe          BL       Write_W5500_1Byte
;;;900    
;;;901    	if((i & CONFLICT) == CONFLICT)//IP地址冲突异常处理
;;;902    	{
;;;903    		 //自己添加代码
;;;904    	}
;;;905    
;;;906    	if((i & UNREACH) == UNREACH)//UDP模式下地址无法到达异常处理
;;;907    	{
;;;908    		//自己添加代码
;;;909    	}
;;;910    	
;;;911    	if((i& IMR_TIMEOUT)==IMR_TIMEOUT)
;;;912    	{
;;;913    		//保留
;;;914    	}
;;;915    	
;;;916    	i=Read_W5500_1Byte(SIR);//读取端口中断标志寄存器	
00001c  2017              MOVS     r0,#0x17
00001e  f7fffffe          BL       Read_W5500_1Byte
000022  4605              MOV      r5,r0
;;;917    	if((i & S0_INT) == S0_INT)//Socket0事件处理 
000024  f0050001          AND      r0,r5,#1
000028  2800              CMP      r0,#0
00002a  d03d              BEQ      |L19.168|
;;;918    	{
;;;919    		j=Read_W5500_SOCK_1Byte(0,Sn_IR);//读取Socket0中断标志寄存器
00002c  2102              MOVS     r1,#2
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       Read_W5500_SOCK_1Byte
000034  4604              MOV      r4,r0
;;;920    		Write_W5500_SOCK_1Byte(0,Sn_IR,j);
000036  4622              MOV      r2,r4
000038  2102              MOVS     r1,#2
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;921    		if(j&IR_CON)//在TCP模式下,Socket0成功连接 
000040  f0040001          AND      r0,r4,#1
000044  b128              CBZ      r0,|L19.82|
;;;922    		{
;;;923    			S0_State|=S_CONN;//网络连接状态0x02,端口完成连接，可以正常传输数据
000046  487f              LDR      r0,|L19.580|
000048  7800              LDRB     r0,[r0,#0]  ; S0_State
00004a  f0400002          ORR      r0,r0,#2
00004e  497d              LDR      r1,|L19.580|
000050  7008              STRB     r0,[r1,#0]
                  |L19.82|
;;;924    		}
;;;925    		if(j&IR_DISCON)//在TCP模式下Socket断开连接处理
000052  f0040002          AND      r0,r4,#2
000056  b150              CBZ      r0,|L19.110|
;;;926    		{
;;;927    			Write_W5500_SOCK_1Byte(0,Sn_CR,CLOSE);//关闭端口,等待重新打开连接 
000058  2210              MOVS     r2,#0x10
00005a  2101              MOVS     r1,#1
00005c  2000              MOVS     r0,#0
00005e  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;928    			Socket_Init(0);		//指定Socket(0~7)初始化,初始化端口0
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       Socket_Init
;;;929    			S0_State=0;//网络连接状态0x00,端口连接失败
000068  2000              MOVS     r0,#0
00006a  4976              LDR      r1,|L19.580|
00006c  7008              STRB     r0,[r1,#0]
                  |L19.110|
;;;930    		}
;;;931    		if(j&IR_SEND_OK)//Socket0数据发送完成,可以再次启动S_tx_process()函数发送数据 
00006e  f0040010          AND      r0,r4,#0x10
000072  b128              CBZ      r0,|L19.128|
;;;932    		{
;;;933    			S0_Data|=S_TRANSMITOK;//端口发送一个数据包完成 
000074  4874              LDR      r0,|L19.584|
000076  7800              LDRB     r0,[r0,#0]  ; S0_Data
000078  f0400002          ORR      r0,r0,#2
00007c  4972              LDR      r1,|L19.584|
00007e  7008              STRB     r0,[r1,#0]
                  |L19.128|
;;;934    		}
;;;935    		if(j&IR_RECV)//Socket接收到数据,可以启动S_rx_process()函数 
000080  f0040004          AND      r0,r4,#4
000084  b128              CBZ      r0,|L19.146|
;;;936    		{
;;;937    			S0_Data|=S_RECEIVE;//端口接收到一个数据包
000086  4870              LDR      r0,|L19.584|
000088  7800              LDRB     r0,[r0,#0]  ; S0_Data
00008a  f0400001          ORR      r0,r0,#1
00008e  496e              LDR      r1,|L19.584|
000090  7008              STRB     r0,[r1,#0]
                  |L19.146|
;;;938    		}
;;;939    		if(j&IR_TIMEOUT)//Socket连接或数据传输超时处理 
000092  f0040008          AND      r0,r4,#8
000096  b138              CBZ      r0,|L19.168|
;;;940    		{
;;;941    			Write_W5500_SOCK_1Byte(0,Sn_CR,CLOSE);// 关闭端口,等待重新打开连接
000098  2210              MOVS     r2,#0x10
00009a  2101              MOVS     r1,#1
00009c  2000              MOVS     r0,#0
00009e  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;942    			S0_State=0;//网络连接状态0x00,端口连接失败
0000a2  2000              MOVS     r0,#0
0000a4  4967              LDR      r1,|L19.580|
0000a6  7008              STRB     r0,[r1,#0]
                  |L19.168|
;;;943    		}
;;;944    	}
;;;945    
;;;946    	if((i & S1_INT) == S1_INT)//Socket1事件处理 
0000a8  f0050002          AND      r0,r5,#2
0000ac  2802              CMP      r0,#2
0000ae  d13d              BNE      |L19.300|
;;;947    	{
;;;948    		j=Read_W5500_SOCK_1Byte(1,Sn_IR);//读取Socket1中断标志寄存器
0000b0  2102              MOVS     r1,#2
0000b2  2001              MOVS     r0,#1
0000b4  f7fffffe          BL       Read_W5500_SOCK_1Byte
0000b8  4604              MOV      r4,r0
;;;949    		Write_W5500_SOCK_1Byte(1,Sn_IR,j);
0000ba  4622              MOV      r2,r4
0000bc  2102              MOVS     r1,#2
0000be  2001              MOVS     r0,#1
0000c0  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;950    		if(j&IR_CON)//在TCP模式下,Socket0成功连接 
0000c4  f0040001          AND      r0,r4,#1
0000c8  b128              CBZ      r0,|L19.214|
;;;951    		{
;;;952    			S1_State|=S_CONN;//网络连接状态0x02,端口完成连接，可以正常传输数据
0000ca  4860              LDR      r0,|L19.588|
0000cc  7800              LDRB     r0,[r0,#0]  ; S1_State
0000ce  f0400002          ORR      r0,r0,#2
0000d2  495e              LDR      r1,|L19.588|
0000d4  7008              STRB     r0,[r1,#0]
                  |L19.214|
;;;953    		}
;;;954    		if(j&IR_DISCON)//在TCP模式下Socket断开连接处理
0000d6  f0040002          AND      r0,r4,#2
0000da  b150              CBZ      r0,|L19.242|
;;;955    		{
;;;956    			Write_W5500_SOCK_1Byte(1,Sn_CR,CLOSE);//关闭端口,等待重新打开连接 
0000dc  2210              MOVS     r2,#0x10
0000de  2101              MOVS     r1,#1
0000e0  4608              MOV      r0,r1
0000e2  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;957    			Socket_Init(1);		//指定Socket(0~7)初始化,初始化端口0
0000e6  2001              MOVS     r0,#1
0000e8  f7fffffe          BL       Socket_Init
;;;958    			S1_State=0;//网络连接状态0x00,端口连接失败
0000ec  2000              MOVS     r0,#0
0000ee  4957              LDR      r1,|L19.588|
0000f0  7008              STRB     r0,[r1,#0]
                  |L19.242|
;;;959    		}
;;;960    		if(j&IR_SEND_OK)//Socket1数据发送完成,可以再次启动S_tx_process()函数发送数据 
0000f2  f0040010          AND      r0,r4,#0x10
0000f6  b128              CBZ      r0,|L19.260|
;;;961    		{
;;;962    			S1_Data|=S_TRANSMITOK;//端口发送一个数据包完成 
0000f8  4855              LDR      r0,|L19.592|
0000fa  7800              LDRB     r0,[r0,#0]  ; S1_Data
0000fc  f0400002          ORR      r0,r0,#2
000100  4953              LDR      r1,|L19.592|
000102  7008              STRB     r0,[r1,#0]
                  |L19.260|
;;;963    		}
;;;964    		if(j&IR_RECV)//Socket接收到数据,可以启动S_rx_process()函数 
000104  f0040004          AND      r0,r4,#4
000108  b128              CBZ      r0,|L19.278|
;;;965    		{
;;;966    			S1_Data|=S_RECEIVE;//端口接收到一个数据包
00010a  4851              LDR      r0,|L19.592|
00010c  7800              LDRB     r0,[r0,#0]  ; S1_Data
00010e  f0400001          ORR      r0,r0,#1
000112  494f              LDR      r1,|L19.592|
000114  7008              STRB     r0,[r1,#0]
                  |L19.278|
;;;967    		}
;;;968    		if(j&IR_TIMEOUT)//Socket连接或数据传输超时处理 
000116  f0040008          AND      r0,r4,#8
00011a  b138              CBZ      r0,|L19.300|
;;;969    		{
;;;970    			Write_W5500_SOCK_1Byte(1,Sn_CR,CLOSE);// 关闭端口,等待重新打开连接
00011c  2210              MOVS     r2,#0x10
00011e  2101              MOVS     r1,#1
000120  4608              MOV      r0,r1
000122  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;971    			S1_State=0;//网络连接状态0x00,端口连接失败
000126  2000              MOVS     r0,#0
000128  4948              LDR      r1,|L19.588|
00012a  7008              STRB     r0,[r1,#0]
                  |L19.300|
;;;972    		}
;;;973    	}
;;;974    	
;;;975    	if((i & S2_INT) == S2_INT)//Socket2事件处理 
00012c  f0050004          AND      r0,r5,#4
000130  2804              CMP      r0,#4
000132  d13d              BNE      |L19.432|
;;;976    	{
;;;977    		j=Read_W5500_SOCK_1Byte(2,Sn_IR);//读取Socket2中断标志寄存器
000134  2102              MOVS     r1,#2
000136  4608              MOV      r0,r1
000138  f7fffffe          BL       Read_W5500_SOCK_1Byte
00013c  4604              MOV      r4,r0
;;;978    		Write_W5500_SOCK_1Byte(2,Sn_IR,j);
00013e  4622              MOV      r2,r4
000140  2102              MOVS     r1,#2
000142  4608              MOV      r0,r1
000144  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;979    		if(j&IR_CON)//在TCP模式下,Socket2成功连接 
000148  f0040001          AND      r0,r4,#1
00014c  b128              CBZ      r0,|L19.346|
;;;980    		{
;;;981    			S2_State|=S_CONN;//网络连接状态0x02,端口完成连接，可以正常传输数据
00014e  4841              LDR      r0,|L19.596|
000150  7800              LDRB     r0,[r0,#0]  ; S2_State
000152  f0400002          ORR      r0,r0,#2
000156  493f              LDR      r1,|L19.596|
000158  7008              STRB     r0,[r1,#0]
                  |L19.346|
;;;982    		}
;;;983    		if(j&IR_DISCON)//在TCP模式下Socket断开连接处理
00015a  f0040002          AND      r0,r4,#2
00015e  b150              CBZ      r0,|L19.374|
;;;984    		{
;;;985    			Write_W5500_SOCK_1Byte(2,Sn_CR,CLOSE);//关闭端口,等待重新打开连接 
000160  2210              MOVS     r2,#0x10
000162  2101              MOVS     r1,#1
000164  2002              MOVS     r0,#2
000166  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;986    			Socket_Init(2);		//指定Socket(0~7)初始化,初始化端口0
00016a  2002              MOVS     r0,#2
00016c  f7fffffe          BL       Socket_Init
;;;987    			S2_State=0;//网络连接状态0x00,端口连接失败
000170  2000              MOVS     r0,#0
000172  4938              LDR      r1,|L19.596|
000174  7008              STRB     r0,[r1,#0]
                  |L19.374|
;;;988    		}
;;;989    		if(j&IR_SEND_OK)//Socket0数据发送完成,可以再次启动S_tx_process()函数发送数据 
000176  f0040010          AND      r0,r4,#0x10
00017a  b128              CBZ      r0,|L19.392|
;;;990    		{
;;;991    			S2_Data|=S_TRANSMITOK;//端口发送一个数据包完成 
00017c  4836              LDR      r0,|L19.600|
00017e  7800              LDRB     r0,[r0,#0]  ; S2_Data
000180  f0400002          ORR      r0,r0,#2
000184  4934              LDR      r1,|L19.600|
000186  7008              STRB     r0,[r1,#0]
                  |L19.392|
;;;992    		}
;;;993    		if(j&IR_RECV)//Socket接收到数据,可以启动S_rx_process()函数 
000188  f0040004          AND      r0,r4,#4
00018c  b128              CBZ      r0,|L19.410|
;;;994    		{
;;;995    			S2_Data|=S_RECEIVE;//端口接收到一个数据包
00018e  4832              LDR      r0,|L19.600|
000190  7800              LDRB     r0,[r0,#0]  ; S2_Data
000192  f0400001          ORR      r0,r0,#1
000196  4930              LDR      r1,|L19.600|
000198  7008              STRB     r0,[r1,#0]
                  |L19.410|
;;;996    		}
;;;997    		if(j&IR_TIMEOUT)//Socket连接或数据传输超时处理 
00019a  f0040008          AND      r0,r4,#8
00019e  b138              CBZ      r0,|L19.432|
;;;998    		{
;;;999    			Write_W5500_SOCK_1Byte(2,Sn_CR,CLOSE);// 关闭端口,等待重新打开连接
0001a0  2210              MOVS     r2,#0x10
0001a2  2101              MOVS     r1,#1
0001a4  2002              MOVS     r0,#2
0001a6  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;1000   			S2_State=0;//网络连接状态0x00,端口连接失败
0001aa  2000              MOVS     r0,#0
0001ac  4929              LDR      r1,|L19.596|
0001ae  7008              STRB     r0,[r1,#0]
                  |L19.432|
;;;1001   		}
;;;1002   	}
;;;1003   	
;;;1004   	if((i & S3_INT) == S3_INT)//Socket3事件处理 
0001b0  f0050008          AND      r0,r5,#8
0001b4  2808              CMP      r0,#8
0001b6  d13d              BNE      |L19.564|
;;;1005   	{
;;;1006   		j=Read_W5500_SOCK_1Byte(3,Sn_IR);//读取Socket3中断标志寄存器
0001b8  2102              MOVS     r1,#2
0001ba  2003              MOVS     r0,#3
0001bc  f7fffffe          BL       Read_W5500_SOCK_1Byte
0001c0  4604              MOV      r4,r0
;;;1007   		Write_W5500_SOCK_1Byte(3,Sn_IR,j);
0001c2  4622              MOV      r2,r4
0001c4  2102              MOVS     r1,#2
0001c6  2003              MOVS     r0,#3
0001c8  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;1008   		if(j&IR_CON)//在TCP模式下,Socket2成功连接 
0001cc  f0040001          AND      r0,r4,#1
0001d0  b128              CBZ      r0,|L19.478|
;;;1009   		{
;;;1010   			S3_State|=S_CONN;//网络连接状态0x02,端口完成连接，可以正常传输数据
0001d2  4822              LDR      r0,|L19.604|
0001d4  7800              LDRB     r0,[r0,#0]  ; S3_State
0001d6  f0400002          ORR      r0,r0,#2
0001da  4920              LDR      r1,|L19.604|
0001dc  7008              STRB     r0,[r1,#0]
                  |L19.478|
;;;1011   		}
;;;1012   		if(j&IR_DISCON)//在TCP模式下Socket断开连接处理
0001de  f0040002          AND      r0,r4,#2
0001e2  b150              CBZ      r0,|L19.506|
;;;1013   		{
;;;1014   			Write_W5500_SOCK_1Byte(3,Sn_CR,CLOSE);//关闭端口,等待重新打开连接 
0001e4  2210              MOVS     r2,#0x10
0001e6  2101              MOVS     r1,#1
0001e8  2003              MOVS     r0,#3
0001ea  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;1015   			Socket_Init(3);		//指定Socket(0~7)初始化,初始化端口0
0001ee  2003              MOVS     r0,#3
0001f0  f7fffffe          BL       Socket_Init
;;;1016   			S3_State=0;//网络连接状态0x00,端口连接失败
0001f4  2000              MOVS     r0,#0
0001f6  4919              LDR      r1,|L19.604|
0001f8  7008              STRB     r0,[r1,#0]
                  |L19.506|
;;;1017   		}
;;;1018   		if(j&IR_SEND_OK)//Socket0数据发送完成,可以再次启动S_tx_process()函数发送数据 
0001fa  f0040010          AND      r0,r4,#0x10
0001fe  b128              CBZ      r0,|L19.524|
;;;1019   		{
;;;1020   			S3_Data|=S_TRANSMITOK;//端口发送一个数据包完成 
000200  4817              LDR      r0,|L19.608|
000202  7800              LDRB     r0,[r0,#0]  ; S3_Data
000204  f0400002          ORR      r0,r0,#2
000208  4915              LDR      r1,|L19.608|
00020a  7008              STRB     r0,[r1,#0]
                  |L19.524|
;;;1021   		}
;;;1022   		if(j&IR_RECV)//Socket接收到数据,可以启动S_rx_process()函数 
00020c  f0040004          AND      r0,r4,#4
000210  b128              CBZ      r0,|L19.542|
;;;1023   		{
;;;1024   			S3_Data|=S_RECEIVE;//端口接收到一个数据包
000212  4813              LDR      r0,|L19.608|
000214  7800              LDRB     r0,[r0,#0]  ; S3_Data
000216  f0400001          ORR      r0,r0,#1
00021a  4911              LDR      r1,|L19.608|
00021c  7008              STRB     r0,[r1,#0]
                  |L19.542|
;;;1025   		}
;;;1026   		if(j&IR_TIMEOUT)//Socket连接或数据传输超时处理 
00021e  f0040008          AND      r0,r4,#8
000222  b138              CBZ      r0,|L19.564|
;;;1027   		{
;;;1028   			Write_W5500_SOCK_1Byte(3,Sn_CR,CLOSE);// 关闭端口,等待重新打开连接
000224  2210              MOVS     r2,#0x10
000226  2101              MOVS     r1,#1
000228  2003              MOVS     r0,#3
00022a  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;1029   			S3_State=0;//网络连接状态0x00,端口连接失败
00022e  2000              MOVS     r0,#0
000230  490a              LDR      r1,|L19.604|
000232  7008              STRB     r0,[r1,#0]
                  |L19.564|
;;;1030   		}
;;;1031   	}
;;;1032   	
;;;1033   		if(Read_W5500_1Byte(SIR) != 0) 
000234  2017              MOVS     r0,#0x17
000236  f7fffffe          BL       Read_W5500_1Byte
00023a  b100              CBZ      r0,|L19.574|
;;;1034   		goto IntDispose;
00023c  e6e2              B        |L19.4|
                  |L19.574|
;;;1035   }
00023e  bd70              POP      {r4-r6,pc}
;;;1036   
                          ENDP

                  |L19.576|
                          DCD      W5500_Interrupt
                  |L19.580|
                          DCD      S0_State
                  |L19.584|
                          DCD      S0_Data
                  |L19.588|
                          DCD      S1_State
                  |L19.592|
                          DCD      S1_Data
                  |L19.596|
                          DCD      S2_State
                  |L19.600|
                          DCD      S2_Data
                  |L19.604|
                          DCD      S3_State
                  |L19.608|
                          DCD      S3_Data

                          AREA ||i.Write_SOCK_Data_Buffer||, CODE, READONLY, ALIGN=2

                  Write_SOCK_Data_Buffer PROC
;;;493    *******************************************************************************/
;;;494    void Write_SOCK_Data_Buffer(SOCKET s, unsigned char *dat_ptr, uint8_t size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;495    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
;;;496    	unsigned short offset,offset1;
;;;497    	unsigned short i;
;;;498    
;;;499    	//如果是UDP模式,可以在此设置目的主机的IP和端口号
;;;500    	if((Read_W5500_SOCK_1Byte(s,Sn_MR)&0x0f) != SOCK_UDP)//如果Socket打开失败
00000a  2100              MOVS     r1,#0
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       Read_W5500_SOCK_1Byte
000012  f000000f          AND      r0,r0,#0xf
000016  2822              CMP      r0,#0x22
000018  d020              BEQ      |L20.92|
;;;501    	{	
;;;502    			if(s==3)
00001a  2e03              CMP      r6,#3
00001c  d10f              BNE      |L20.62|
;;;503    			{
;;;504    				Write_W5500_SOCK_4Byte(s, Sn_DIPR, NTP_DIPR);//设置目的主机IP  		
00001e  4a43              LDR      r2,|L20.300|
000020  210c              MOVS     r1,#0xc
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       Write_W5500_SOCK_4Byte
;;;505    				Write_W5500_SOCK_2Byte(s, Sn_DPORTR, NTP_DPORT[0]*256+NTP_DPORT[1]);//设置目的主机端口号	
000028  4841              LDR      r0,|L20.304|
00002a  7841              LDRB     r1,[r0,#1]  ; NTP_DPORT
00002c  7800              LDRB     r0,[r0,#0]  ; NTP_DPORT
00002e  eb012000          ADD      r0,r1,r0,LSL #8
000032  b282              UXTH     r2,r0
000034  2110              MOVS     r1,#0x10
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       Write_W5500_SOCK_2Byte
00003c  e00e              B        |L20.92|
                  |L20.62|
;;;506    			}
;;;507    			else
;;;508    			{
;;;509    				Write_W5500_SOCK_4Byte(s, Sn_DIPR, UDP_DIPR);//设置目的主机IP  		
00003e  4a3d              LDR      r2,|L20.308|
000040  210c              MOVS     r1,#0xc
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       Write_W5500_SOCK_4Byte
;;;510    				Write_W5500_SOCK_2Byte(s, Sn_DPORTR, UDP_DPORT[0]*256+UDP_DPORT[1]);//设置目的主机端口号	
000048  483b              LDR      r0,|L20.312|
00004a  7841              LDRB     r1,[r0,#1]  ; UDP_DPORT
00004c  7800              LDRB     r0,[r0,#0]  ; UDP_DPORT
00004e  eb012000          ADD      r0,r1,r0,LSL #8
000052  b282              UXTH     r2,r0
000054  2110              MOVS     r1,#0x10
000056  4630              MOV      r0,r6
000058  f7fffffe          BL       Write_W5500_SOCK_2Byte
                  |L20.92|
;;;511    			}				
;;;512    	}
;;;513    
;;;514    	offset=Read_W5500_SOCK_2Byte(s,Sn_TX_WR);
00005c  2124              MOVS     r1,#0x24
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       Read_W5500_SOCK_2Byte
000064  4607              MOV      r7,r0
;;;515    	offset1=offset;
000066  46b9              MOV      r9,r7
;;;516    	offset&=(S_TX_SIZE-1);//计算实际的物理地址
000068  f3c7070a          UBFX     r7,r7,#0,#11
;;;517    
;;;518    	GPIO_ResetBits(W5500_SCS_PORT, W5500_SCS);//置W5500的SCS为低电平
00006c  f44f5180          MOV      r1,#0x1000
000070  4832              LDR      r0,|L20.316|
000072  f7fffffe          BL       GPIO_ResetBits
;;;519    
;;;520    	SPI2_Send_Short(offset);//写16位地址
000076  4638              MOV      r0,r7
000078  f7fffffe          BL       SPI2_Send_Short
;;;521    	SPI2_Send_Byte(VDM|RWB_WRITE|(s*0x20+0x10));//写控制字节,N个字节数据长度,写数据,选择端口s的寄存器
00007c  2110              MOVS     r1,#0x10
00007e  eb011146          ADD      r1,r1,r6,LSL #5
000082  b2c9              UXTB     r1,r1
000084  f0410004          ORR      r0,r1,#4
000088  f7fffffe          BL       SPI2_Send_Byte
;;;522    
;;;523    	if((offset+size)<S_TX_SIZE)//如果最大地址未超过W5500发送缓冲区寄存器的最大地址
00008c  eb070008          ADD      r0,r7,r8
000090  f5b06f00          CMP      r0,#0x800
000094  da0a              BGE      |L20.172|
;;;524    	{
;;;525    		for(i=0;i<size;i++)//循环写入size个字节数据
000096  2400              MOVS     r4,#0
000098  e005              B        |L20.166|
                  |L20.154|
;;;526    		{
;;;527    			SPI2_Send_Byte(*dat_ptr++);//写入一个字节的数据		
00009a  f8150b01          LDRB     r0,[r5],#1
00009e  f7fffffe          BL       SPI2_Send_Byte
0000a2  1c60              ADDS     r0,r4,#1              ;525
0000a4  b284              UXTH     r4,r0                 ;525
                  |L20.166|
0000a6  4544              CMP      r4,r8                 ;525
0000a8  dbf7              BLT      |L20.154|
0000aa  e02a              B        |L20.258|
                  |L20.172|
;;;528    		}
;;;529    	}
;;;530    	else//如果最大地址超过W5500发送缓冲区寄存器的最大地址
;;;531    	{
;;;532    		offset=S_TX_SIZE-offset;
0000ac  f5c76000          RSB      r0,r7,#0x800
0000b0  b287              UXTH     r7,r0
;;;533    		for(i=0;i<offset;i++)//循环写入前offset个字节数据
0000b2  2400              MOVS     r4,#0
0000b4  e005              B        |L20.194|
                  |L20.182|
;;;534    		{
;;;535    			SPI2_Send_Byte(*dat_ptr++);//写入一个字节的数据
0000b6  f8150b01          LDRB     r0,[r5],#1
0000ba  f7fffffe          BL       SPI2_Send_Byte
0000be  1c60              ADDS     r0,r4,#1              ;533
0000c0  b284              UXTH     r4,r0                 ;533
                  |L20.194|
0000c2  42bc              CMP      r4,r7                 ;533
0000c4  dbf7              BLT      |L20.182|
;;;536    		}
;;;537    		GPIO_SetBits(W5500_SCS_PORT, W5500_SCS); //置W5500的SCS为高电平
0000c6  f44f5180          MOV      r1,#0x1000
0000ca  481c              LDR      r0,|L20.316|
0000cc  f7fffffe          BL       GPIO_SetBits
;;;538    
;;;539    		GPIO_ResetBits(W5500_SCS_PORT, W5500_SCS);//置W5500的SCS为低电平
0000d0  f44f5180          MOV      r1,#0x1000
0000d4  4819              LDR      r0,|L20.316|
0000d6  f7fffffe          BL       GPIO_ResetBits
;;;540    
;;;541    		SPI2_Send_Short(0x00);//写16位地址
0000da  2000              MOVS     r0,#0
0000dc  f7fffffe          BL       SPI2_Send_Short
;;;542    		SPI2_Send_Byte(VDM|RWB_WRITE|(s*0x20+0x10));//写控制字节,N个字节数据长度,写数据,选择端口s的寄存器
0000e0  2110              MOVS     r1,#0x10
0000e2  eb011146          ADD      r1,r1,r6,LSL #5
0000e6  b2c9              UXTB     r1,r1
0000e8  f0410004          ORR      r0,r1,#4
0000ec  f7fffffe          BL       SPI2_Send_Byte
;;;543    
;;;544    		for(;i<size;i++)//循环写入size-offset个字节数据
0000f0  e005              B        |L20.254|
                  |L20.242|
;;;545    		{
;;;546    			SPI2_Send_Byte(*dat_ptr++);//写入一个字节的数据
0000f2  f8150b01          LDRB     r0,[r5],#1
0000f6  f7fffffe          BL       SPI2_Send_Byte
0000fa  1c60              ADDS     r0,r4,#1              ;544
0000fc  b284              UXTH     r4,r0                 ;544
                  |L20.254|
0000fe  4544              CMP      r4,r8                 ;544
000100  dbf7              BLT      |L20.242|
                  |L20.258|
;;;547    		}
;;;548    	}
;;;549    	GPIO_SetBits(W5500_SCS_PORT, W5500_SCS); //置W5500的SCS为高电平
000102  f44f5180          MOV      r1,#0x1000
000106  480d              LDR      r0,|L20.316|
000108  f7fffffe          BL       GPIO_SetBits
;;;550    
;;;551    	offset1+=size;//更新实际物理地址,即下次写待发送数据到发送数据缓冲区的起始地址
00010c  eb090008          ADD      r0,r9,r8
000110  fa1ff980          UXTH     r9,r0
;;;552    	Write_W5500_SOCK_2Byte(s, Sn_TX_WR, offset1);
000114  464a              MOV      r2,r9
000116  2124              MOVS     r1,#0x24
000118  4630              MOV      r0,r6
00011a  f7fffffe          BL       Write_W5500_SOCK_2Byte
;;;553    	Write_W5500_SOCK_1Byte(s, Sn_CR, SEND);//发送启动发送命令				
00011e  2220              MOVS     r2,#0x20
000120  2101              MOVS     r1,#1
000122  4630              MOV      r0,r6
000124  f7fffffe          BL       Write_W5500_SOCK_1Byte
;;;554    }
000128  e8bd87f0          POP      {r4-r10,pc}
;;;555    
                          ENDP

                  |L20.300|
                          DCD      NTP_DIPR
                  |L20.304|
                          DCD      NTP_DPORT
                  |L20.308|
                          DCD      UDP_DIPR
                  |L20.312|
                          DCD      UDP_DPORT
                  |L20.316|
                          DCD      0x40010c00

                          AREA ||i.Write_W5500_1Byte||, CODE, READONLY, ALIGN=2

                  Write_W5500_1Byte PROC
;;;218    *******************************************************************************/
;;;219    void Write_W5500_1Byte(unsigned short reg, unsigned char dat)
000000  b570              PUSH     {r4-r6,lr}
;;;220    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;221    	GPIO_ResetBits(W5500_SCS_PORT, W5500_SCS);//置W5500的SCS为低电平
000006  f44f5180          MOV      r1,#0x1000
00000a  4809              LDR      r0,|L21.48|
00000c  f7fffffe          BL       GPIO_ResetBits
;;;222    
;;;223    	SPI2_Send_Short(reg);//通过SPI2写16位寄存器地址
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       SPI2_Send_Short
;;;224    	SPI2_Send_Byte(FDM1|RWB_WRITE|COMMON_R);//通过SPI2写控制字节,1个字节数据长度,写数据,选择通用寄存器
000016  2005              MOVS     r0,#5
000018  f7fffffe          BL       SPI2_Send_Byte
;;;225    	SPI2_Send_Byte(dat);//写1个字节数据
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SPI2_Send_Byte
;;;226    
;;;227    	GPIO_SetBits(W5500_SCS_PORT, W5500_SCS); //置W5500的SCS为高电平
000022  f44f5180          MOV      r1,#0x1000
000026  4802              LDR      r0,|L21.48|
000028  f7fffffe          BL       GPIO_SetBits
;;;228    }
00002c  bd70              POP      {r4-r6,pc}
;;;229    
                          ENDP

00002e  0000              DCW      0x0000
                  |L21.48|
                          DCD      0x40010c00

                          AREA ||i.Write_W5500_2Byte||, CODE, READONLY, ALIGN=2

                  Write_W5500_2Byte PROC
;;;237    *******************************************************************************/
;;;238    void Write_W5500_2Byte(unsigned short reg, unsigned short dat)
000000  b570              PUSH     {r4-r6,lr}
;;;239    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;240    	GPIO_ResetBits(W5500_SCS_PORT, W5500_SCS);//置W5500的SCS为低电平
000006  f44f5180          MOV      r1,#0x1000
00000a  4809              LDR      r0,|L22.48|
00000c  f7fffffe          BL       GPIO_ResetBits
;;;241    		
;;;242    	SPI2_Send_Short(reg);//通过SPI2写16位寄存器地址
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       SPI2_Send_Short
;;;243    	SPI2_Send_Byte(FDM2|RWB_WRITE|COMMON_R);//通过SPI2写控制字节,2个字节数据长度,写数据,选择通用寄存器
000016  2006              MOVS     r0,#6
000018  f7fffffe          BL       SPI2_Send_Byte
;;;244    	SPI2_Send_Short(dat);//写16位数据
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SPI2_Send_Short
;;;245    
;;;246    	GPIO_SetBits(W5500_SCS_PORT, W5500_SCS); //置W5500的SCS为高电平
000022  f44f5180          MOV      r1,#0x1000
000026  4802              LDR      r0,|L22.48|
000028  f7fffffe          BL       GPIO_SetBits
;;;247    }
00002c  bd70              POP      {r4-r6,pc}
;;;248    
                          ENDP

00002e  0000              DCW      0x0000
                  |L22.48|
                          DCD      0x40010c00

                          AREA ||i.Write_W5500_SOCK_1Byte||, CODE, READONLY, ALIGN=2

                  Write_W5500_SOCK_1Byte PROC
;;;281    *******************************************************************************/
;;;282    void Write_W5500_SOCK_1Byte(SOCKET s, unsigned short reg, unsigned char dat)
000000  b570              PUSH     {r4-r6,lr}
;;;283    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;284    	GPIO_ResetBits(W5500_SCS_PORT, W5500_SCS);//置W5500的SCS为低电平	
000008  f44f5180          MOV      r1,#0x1000
00000c  480b              LDR      r0,|L23.60|
00000e  f7fffffe          BL       GPIO_ResetBits
;;;285    		
;;;286    	SPI2_Send_Short(reg);//通过SPI2写16位寄存器地址
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       SPI2_Send_Short
;;;287    	SPI2_Send_Byte(FDM1|RWB_WRITE|(s*0x20+0x08));//通过SPI2写控制字节,1个字节数据长度,写数据,选择端口s的寄存器
000018  2108              MOVS     r1,#8
00001a  eb011144          ADD      r1,r1,r4,LSL #5
00001e  b2c9              UXTB     r1,r1
000020  f0410005          ORR      r0,r1,#5
000024  f7fffffe          BL       SPI2_Send_Byte
;;;288    	SPI2_Send_Byte(dat);//写1个字节数据
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       SPI2_Send_Byte
;;;289    
;;;290    	GPIO_SetBits(W5500_SCS_PORT, W5500_SCS); //置W5500的SCS为高电平
00002e  f44f5180          MOV      r1,#0x1000
000032  4802              LDR      r0,|L23.60|
000034  f7fffffe          BL       GPIO_SetBits
;;;291    }
000038  bd70              POP      {r4-r6,pc}
;;;292    
                          ENDP

00003a  0000              DCW      0x0000
                  |L23.60|
                          DCD      0x40010c00

                          AREA ||i.Write_W5500_SOCK_2Byte||, CODE, READONLY, ALIGN=2

                  Write_W5500_SOCK_2Byte PROC
;;;300    *******************************************************************************/
;;;301    void Write_W5500_SOCK_2Byte(SOCKET s, unsigned short reg, unsigned short dat)
000000  b570              PUSH     {r4-r6,lr}
;;;302    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;303    	GPIO_ResetBits(W5500_SCS_PORT, W5500_SCS);//置W5500的SCS为低电平
000008  f44f5180          MOV      r1,#0x1000
00000c  480b              LDR      r0,|L24.60|
00000e  f7fffffe          BL       GPIO_ResetBits
;;;304    			
;;;305    	SPI2_Send_Short(reg);//通过SPI2写16位寄存器地址
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       SPI2_Send_Short
;;;306    	SPI2_Send_Byte(FDM2|RWB_WRITE|(s*0x20+0x08));//通过SPI2写控制字节,2个字节数据长度,写数据,选择端口s的寄存器
000018  2108              MOVS     r1,#8
00001a  eb011144          ADD      r1,r1,r4,LSL #5
00001e  b2c9              UXTB     r1,r1
000020  f0410006          ORR      r0,r1,#6
000024  f7fffffe          BL       SPI2_Send_Byte
;;;307    	SPI2_Send_Short(dat);//写16位数据
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       SPI2_Send_Short
;;;308    
;;;309    	GPIO_SetBits(W5500_SCS_PORT, W5500_SCS); //置W5500的SCS为高电平
00002e  f44f5180          MOV      r1,#0x1000
000032  4802              LDR      r0,|L24.60|
000034  f7fffffe          BL       GPIO_SetBits
;;;310    }
000038  bd70              POP      {r4-r6,pc}
;;;311    
                          ENDP

00003a  0000              DCW      0x0000
                  |L24.60|
                          DCD      0x40010c00

                          AREA ||i.Write_W5500_SOCK_4Byte||, CODE, READONLY, ALIGN=2

                  Write_W5500_SOCK_4Byte PROC
;;;319    *******************************************************************************/
;;;320    void Write_W5500_SOCK_4Byte(SOCKET s, unsigned short reg, unsigned char *dat_ptr)
000000  b570              PUSH     {r4-r6,lr}
;;;321    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;322    	GPIO_ResetBits(W5500_SCS_PORT, W5500_SCS);//置W5500的SCS为低电平
000008  f44f5180          MOV      r1,#0x1000
00000c  4811              LDR      r0,|L25.84|
00000e  f7fffffe          BL       GPIO_ResetBits
;;;323    			
;;;324    	SPI2_Send_Short(reg);//通过SPI2写16位寄存器地址
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       SPI2_Send_Short
;;;325    	SPI2_Send_Byte(FDM4|RWB_WRITE|(s*0x20+0x08));//通过SPI2写控制字节,4个字节数据长度,写数据,选择端口s的寄存器
000018  2108              MOVS     r1,#8
00001a  eb011145          ADD      r1,r1,r5,LSL #5
00001e  b2c9              UXTB     r1,r1
000020  f0410007          ORR      r0,r1,#7
000024  f7fffffe          BL       SPI2_Send_Byte
;;;326    
;;;327    	SPI2_Send_Byte(*dat_ptr++);//写第1个字节数据
000028  f8140b01          LDRB     r0,[r4],#1
00002c  f7fffffe          BL       SPI2_Send_Byte
;;;328    	SPI2_Send_Byte(*dat_ptr++);//写第2个字节数据
000030  f8140b01          LDRB     r0,[r4],#1
000034  f7fffffe          BL       SPI2_Send_Byte
;;;329    	SPI2_Send_Byte(*dat_ptr++);//写第3个字节数据
000038  f8140b01          LDRB     r0,[r4],#1
00003c  f7fffffe          BL       SPI2_Send_Byte
;;;330    	SPI2_Send_Byte(*dat_ptr++);//写第4个字节数据
000040  f8140b01          LDRB     r0,[r4],#1
000044  f7fffffe          BL       SPI2_Send_Byte
;;;331    
;;;332    	GPIO_SetBits(W5500_SCS_PORT, W5500_SCS); //置W5500的SCS为高电平
000048  f44f5180          MOV      r1,#0x1000
00004c  4801              LDR      r0,|L25.84|
00004e  f7fffffe          BL       GPIO_SetBits
;;;333    }
000052  bd70              POP      {r4-r6,pc}
;;;334    
                          ENDP

                  |L25.84|
                          DCD      0x40010c00

                          AREA ||i.Write_W5500_nByte||, CODE, READONLY, ALIGN=2

                  Write_W5500_nByte PROC
;;;256    *******************************************************************************/
;;;257    void Write_W5500_nByte(unsigned short reg, unsigned char *dat_ptr, unsigned short size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;258    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;259    	unsigned short i;
;;;260    
;;;261    	GPIO_ResetBits(W5500_SCS_PORT, W5500_SCS);//置W5500的SCS为低电平	
00000a  f44f5180          MOV      r1,#0x1000
00000e  480d              LDR      r0,|L26.68|
000010  f7fffffe          BL       GPIO_ResetBits
;;;262    		
;;;263    	SPI2_Send_Short(reg);//通过SPI2写16位寄存器地址
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       SPI2_Send_Short
;;;264    	SPI2_Send_Byte(VDM|RWB_WRITE|COMMON_R);//通过SPI2写控制字节,N个字节数据长度,写数据,选择通用寄存器
00001a  2004              MOVS     r0,#4
00001c  f7fffffe          BL       SPI2_Send_Byte
;;;265    
;;;266    	for(i=0;i<size;i++)//循环将缓冲区的size个字节数据写入W5500
000020  2600              MOVS     r6,#0
000022  e005              B        |L26.48|
                  |L26.36|
;;;267    	{
;;;268    		SPI2_Send_Byte(*dat_ptr++);//写一个字节数据
000024  f8140b01          LDRB     r0,[r4],#1
000028  f7fffffe          BL       SPI2_Send_Byte
00002c  1c70              ADDS     r0,r6,#1              ;266
00002e  b286              UXTH     r6,r0                 ;266
                  |L26.48|
000030  42ae              CMP      r6,r5                 ;266
000032  dbf7              BLT      |L26.36|
;;;269    	}
;;;270    
;;;271    	GPIO_SetBits(W5500_SCS_PORT, W5500_SCS); //置W5500的SCS为高电平
000034  f44f5180          MOV      r1,#0x1000
000038  4802              LDR      r0,|L26.68|
00003a  f7fffffe          BL       GPIO_SetBits
;;;272    }
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;273    
                          ENDP

000042  0000              DCW      0x0000
                  |L26.68|
                          DCD      0x40010c00

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  Socket0_Rx_Buffer
                          %        512
                  Socket0_Tx_Buffer
                          %        256
                  Socket1_Rx_Buffer
                          %        2048
                  Socket1_Tx_Buffer
                          %        128
                  Socket2_Rx_Buffer
                          %        128
                  Socket3_Rx_Buffer
                          %        128

                          AREA ||.data||, DATA, ALIGN=0

                  Gateway_IP
                          DCDU     0x00000000
                  Sub_Mask
                          DCDU     0x00000000
                  Phy_Addr
                          DCDU     0x00000000
00000c  0000              DCB      0x00,0x00
                  IP_Addr
00000e  0000              DCB      0x00,0x00
000010  0000              DCB      0x00,0x00
                  S0_Port
000012  0000              DCB      0x00,0x00
                  S0_DIP
                          DCDU     0x00000000
                  S0_DPort
000018  0000              DCB      0x00,0x00
                  S1_Port
00001a  0000              DCB      0x00,0x00
                  S1_DIP
                          DCDU     0x00000000
                  S1_DPort
000020  0000              DCB      0x00,0x00
                  S2_Port
000022  0000              DCB      0x00,0x00
                  S2_DIP
                          DCDU     0x00000000
                  S2_DPort
000028  0000              DCB      0x00,0x00
                  S3_Port
00002a  0000              DCB      0x00,0x00
                  S3_DIP
                          DCDU     0x00000000
                  S3_DPort
000030  0000              DCB      0x00,0x00
                  UDP_DIPR
000032  0000              DCB      0x00,0x00
000034  0000              DCB      0x00,0x00
                  UDP_DPORT
000036  0000              DCB      0x00,0x00
                  NTP_DIPR
                          DCDU     0x00000000
                  NTP_DPORT
00003c  0000              DCB      0x00,0x00
                  S0_Mode
00003e  03                DCB      0x03
                  S1_Mode
00003f  03                DCB      0x03
                  S2_Mode
000040  03                DCB      0x03
                  S3_Mode
000041  03                DCB      0x03
                  S0_State
000042  00                DCB      0x00
                  S1_State
000043  00                DCB      0x00
                  S2_State
000044  00                DCB      0x00
                  S3_State
000045  00                DCB      0x00
                  S0_Data
000046  00                DCB      0x00
                  S1_Data
000047  00                DCB      0x00
                  S2_Data
000048  00                DCB      0x00
                  S3_Data
000049  00                DCB      0x00
                  W5500_Interrupt
00004a  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\W5500.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_W5500_c_S0_Mode____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_W5500_c_S0_Mode____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_W5500_c_S0_Mode____REVSH|
#line 128
|__asm___7_W5500_c_S0_Mode____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
